/**********************************************************
 *            AUTOGENERATED FILE                          *
 *             DO NOT MODIFY IT                           *
 *                                                        *
 * To add new commands :                                  *
 *  - Modify ../Xml/commands.xml file                     *
 *  - Re-run generateFeatureControllers.py script         *
 *                                                        *
 **********************************************************/

/**
* @file ARCONTROLLER_Feature.c
* @brief Feature controller allow to send command related of a Feature.
*/

#include <stdio.h>
#include <libARSAL/ARSAL_Mutex.h>
#include <libARCommands/ARCommands.h>
#include <libARController/ARCONTROLLER_Network.h>
#include <libARController/ARCONTROLLER_Feature.h>

#include "ARCONTROLLER_Feature.h"

#define ARCONTROLLER_FEATURE_TAG "ARCONTROLLER_Feature"

void ARCONTROLLER_Feature_DeleteCommandsDictionary (ARCONTROLLER_DICTIONARY_COMMANDS_t **dictionary)
{
    // -- Delete a commands dictionary --
    
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdTmp = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictTmp = NULL;
    
    if (dictionary != NULL)
    {
        if ((*dictionary) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictionary), dictCmdElement, dictCmdTmp)
            {
                // Free the hash table contents
                HASH_ITER(hh, dictCmdElement->elements, dictElement, dictTmp)
                {
                    // for each element
                    
                    if (dictElement->arguments != NULL)
                    {
                        // delete all arguments
                        ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(dictElement->arguments));
                    }
                    
                    if (dictElement->key != NULL)
                    {
                        // free the key of the element
                        free (dictElement->key);
                        dictElement->key = NULL;
                    }
                    
                    HASH_DEL (dictCmdElement->elements, dictElement);
                    free (dictElement);
                    dictElement = NULL;
                }
                
                HASH_DEL ((*dictionary), dictCmdElement);
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
            
            free (*dictionary);
            (*dictionary) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_Feature_NewCommandsElement (int commandKey, eARCONTROLLER_ERROR *error)
{
    // -- New Commands Element --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
    
    if (dictCmdElement != NULL)
    {
        dictCmdElement->command = commandKey;
        dictCmdElement->elements = NULL;
    }
    else
    {
        localError = ARCONTROLLER_ERROR_ALLOC;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictCmdElement;
}

void ARCONTROLLER_Feature_DeleteCommandsElement (ARCONTROLLER_DICTIONARY_COMMANDS_t **dictCmdElement)
{
    // -- Delete a commands Element --
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictTmp = NULL;
    
    if (dictCmdElement != NULL)
    {
        if ((*dictCmdElement) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictCmdElement)->elements, dictElement, dictTmp)
            {
                // for each element
                
                HASH_DEL ((*dictCmdElement)->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            
            free (*dictCmdElement);
            (*dictCmdElement) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_DeleteElement (ARCONTROLLER_DICTIONARY_ELEMENT_t **element)
{
    // -- Delete an element --
    
    if (element != NULL)
    {
        if ((*element) != NULL)
        {
            if ((*element)->arguments != NULL)
            {
                // delete all arguments
                ARCONTROLLER_Feature_DeleteArgumentsDictionary (&((*element)->arguments));
            }
            
            if ((*element)->key != NULL)
            {
                // free the key of the element
                free ((*element)->key);
                (*element)->key = NULL;
            }
            
            free (*element);
            (*element) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_DeleteArgumentsDictionary (ARCONTROLLER_DICTIONARY_ARG_t **dictionary)
{
    // -- Delete arguments dictionary --
    
    ARCONTROLLER_DICTIONARY_ARG_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ARG_t *dictTmp = NULL;
    
    if (dictionary != NULL)
    {
        if ((*dictionary) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictionary), dictElement, dictTmp)
            {
                /* for each element of the arguments dictionary */
                if ((dictElement->valueType == ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING) && (dictElement->value.String != NULL))
                {
                    free (dictElement->value.String);
                    dictElement->value.String = NULL;
                }
                
                HASH_DEL((*dictionary), dictElement);
                free(dictElement);
                dictElement = NULL;
            }
            
            free (*dictionary);
            (*dictionary) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_AddElement (ARCONTROLLER_DICTIONARY_ELEMENT_t **elementDict, ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement)
{
    // -- Set new element in CommandElements --
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    
    // Find if the element already exist
    HASH_FIND_STR ((*elementDict), newElement->key, oldElement);
    if (oldElement != NULL)
    {
        HASH_REPLACE_STR ((*elementDict), key, newElement, oldElement);
        
        ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
        free (oldElement);
        oldElement = NULL;
    }
    else
    {
        HASH_ADD_KEYPTR (hh, (*elementDict), newElement->key, strlen(newElement->key), newElement);
    }
    
}

/*******************************
 * --- FEATURE generic --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

ARCONTROLLER_FEATURE_Generic_t *ARCONTROLLER_FEATURE_Generic_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Generic_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Generic_t));
        if (featureController != NULL)
        {
            featureController->sendDefault = ARCONTROLLER_FEATURE_Generic_SendDefault;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Generic_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_Generic_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Generic_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Generic_Delete (ARCONTROLLER_FEATURE_Generic_t **feature)
{
    // -- Delete the generic feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_Generic_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Generic_GetDictionary (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the generic Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_AddCallback (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Generic</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_RemoveCallback (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Generic</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_RegisterARCommands (ARCONTROLLER_FEATURE_Generic_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_UnregisterARCommands (ARCONTROLLER_FEATURE_Generic_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_SendDefault (ARCONTROLLER_FEATURE_Generic_t *feature)
{
    // -- Send a command <code>Default</code> in project <code>Generic</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Default command
        cmdError = ARCOMMANDS_Generator_GenerateGenericDefault(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_SetNetworkController (ARCONTROLLER_FEATURE_Generic_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Generic_GetCommandElements (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE ARDrone3 --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_ardrone3_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_ardrone3_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordevent_videoeventchanged_error";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_flyingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_navigatehomestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON = "arcontroller_dictionary_key_ardrone3_pilotingstate_navigatehomestatechanged_reason";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedx";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedz";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_roll";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_pitch";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_yaw";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_autotakeoffmodechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_altitudechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DX = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dx";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DY = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DZ = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dz";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DPSI = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dpsi";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_absolutcontrolchanged_on";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_noflyovermaxdistancechanged_shouldnotflyover";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxhorizontalspeed_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALSPEED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxverticalspeed_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxhorizontalacceleration_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxverticalacceleration_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXROTATIONSPEED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxrotationspeed_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_bankedturnchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_minaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_minaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_minaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingdirectionchanged_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingradiuschanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingradiuschanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingradiuschanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_pitchmodechanged_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_LANDINGMODECHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_landingmodechanged_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_hullprotectionchanged_present";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_outdoorchanged_outdoor";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxpitchrollrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxpitchrollrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxpitchrollrotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecuritychanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecurity_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEY = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecurity_key";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecurity_keytype";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_MOTOR_NUMBER = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_motor_number";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_SOFTWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_HARDWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productgpsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productgpsversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORIDS = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorstatechanged_motorids";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorstatechanged_motorerror";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED_VERSION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorsoftwareversionchanged_version";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_NBFLIGHTS = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_nbflights";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_LASTFLIGHTDURATION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_lastflightduration";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_TOTALFLIGHTDURATION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_totalflightduration";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorlasterrorchanged_motorerror";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID_SERIALID = "arcontroller_dictionary_key_ardrone3_settingsstate_p7id_serialid";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_pictureformatchanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_autowhitebalancechanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_value";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_value";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_enabled";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_INTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_interval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MININTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_mininterval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MAXINTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_maxinterval";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoautorecordchanged_enabled";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoautorecordchanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videostabilizationmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_mediastreamingstate_videoenablechanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED_FIXED = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_gpsfixstatechanged_fixed";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_gpsupdatestatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_hometypechanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_returnhomedelaychanged_delay";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_orientation_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_orientation_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_defaultcameraorientation_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_defaultcameraorientation_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY = "arcontroller_dictionary_key_ardrone3_antiflickeringstate_electricfrequencychanged_frequency";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_antiflickeringstate_modechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE = "arcontroller_dictionary_key_ardrone3_gpsstate_numberofsatellitechanged_numberofsatellite";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypeavailabilitychanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypeavailabilitychanged_available";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypechosenchanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES = "arcontroller_dictionary_key_ardrone3_prostate_features_features";

ARCONTROLLER_FEATURE_ARDrone3_t *ARCONTROLLER_FEATURE_ARDrone3_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_ARDrone3_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingFlatTrim = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingFlatTrim;
            featureController->sendPilotingTakeOff = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingTakeOff;
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDRoll;
            featureController->setPilotingPCMDPitch = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPitch;
            featureController->setPilotingPCMDYaw = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDYaw;
            featureController->setPilotingPCMDGaz = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDGaz;
            featureController->setPilotingPCMDTimestampAndSeqNum = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDTimestampAndSeqNum;
            featureController->sendPilotingLanding = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingLanding;
            featureController->sendPilotingEmergency = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingEmergency;
            featureController->sendPilotingNavigateHome = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingNavigateHome;
            featureController->sendPilotingAutoTakeOffMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingAutoTakeOffMode;
            featureController->sendPilotingMoveBy = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingMoveBy;
            featureController->sendPilotingUserTakeOff = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingUserTakeOff;
            featureController->sendPilotingCircle = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingCircle;
            featureController->sendAnimationsFlip = ARCONTROLLER_FEATURE_ARDrone3_SendAnimationsFlip;
            featureController->sendCameraOrientation = ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientation;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPicture;
            featureController->sendMediaRecordVideo = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideo;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideoV2;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiAuthChannel;
            featureController->sendPilotingSettingsMaxAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxAltitude;
            featureController->sendPilotingSettingsMaxTilt = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxTilt;
            featureController->sendPilotingSettingsAbsolutControl = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsAbsolutControl;
            featureController->sendPilotingSettingsMaxDistance = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxDistance;
            featureController->sendPilotingSettingsNoFlyOverMaxDistance = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsNoFlyOverMaxDistance;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxHorizontalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalSpeed;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxVerticalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalSpeed;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxVerticalAcceleration = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalAcceleration;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxRotationSpeed;
            featureController->sendPilotingSettingsBankedTurn = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsBankedTurn;
            featureController->sendPilotingSettingsMinAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMinAltitude;
            featureController->sendPilotingSettingsCirclingDirection = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingDirection;
            featureController->sendPilotingSettingsCirclingRadius = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingRadius;
            featureController->sendPilotingSettingsCirclingAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingAltitude;
            featureController->sendPilotingSettingsPitchMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsPitchMode;
            featureController->sendPilotingSettingsLandingMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsLandingMode;
            featureController->sendSpeedSettingsMaxVerticalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxVerticalSpeed;
            featureController->sendSpeedSettingsMaxRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxRotationSpeed;
            featureController->sendSpeedSettingsHullProtection = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsHullProtection;
            featureController->sendSpeedSettingsOutdoor = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsOutdoor;
            featureController->sendSpeedSettingsMaxPitchRollRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxPitchRollRotationSpeed;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSelection;
            featureController->sendNetworkSettingsWifiSecurity = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSecurity;
            featureController->sendPictureSettingsPictureFormatSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsPictureFormatSelection;
            featureController->sendPictureSettingsAutoWhiteBalanceSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsAutoWhiteBalanceSelection;
            featureController->sendPictureSettingsExpositionSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsExpositionSelection;
            featureController->sendPictureSettingsSaturationSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsSaturationSelection;
            featureController->sendPictureSettingsTimelapseSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsTimelapseSelection;
            featureController->sendPictureSettingsVideoAutorecordSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoAutorecordSelection;
            featureController->sendPictureSettingsVideoStabilizationMode = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoStabilizationMode;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoEnable;
            featureController->sendGPSSettingsSetHome = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSetHome;
            featureController->sendGPSSettingsResetHome = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsResetHome;
            featureController->sendGPSSettingsSendControllerGPS = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSendControllerGPS;
            featureController->sendGPSSettingsHomeType = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsHomeType;
            featureController->sendGPSSettingsReturnHomeDelay = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsReturnHomeDelay;
            featureController->sendAntiflickeringElectricFrequency = ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringElectricFrequency;
            featureController->sendAntiflickeringSetMode = ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringSetMode;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_ARDrone3_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_ARDrone3_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_ARDrone3_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_ARDrone3_Delete (ARCONTROLLER_FEATURE_ARDrone3_t **feature)
{
    // -- Delete the ARDrone3 feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_ARDrone3_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_ARDrone3_GetDictionary (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the ARDrone3 Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_AddCallback (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>ARDrone3</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_RemoveCallback (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>ARDrone3</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_RegisterARCommands (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventVideoEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlatTrimChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateNavigateHomeStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAttitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAutoTakeOffModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingEventMoveByEndCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxTiltChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAbsolutControlChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxDistanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateBankedTurnChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMinAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingDirectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingRadiusChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStatePitchModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateLandingModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateLandingModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxVerticalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateHullProtectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateOutdoorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductMotorVersionListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductGPSVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorSoftwareVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorFlightsStatusChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorLastErrorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateP7IDCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStatePictureFormatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateAutoWhiteBalanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateExpositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateSaturationChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateTimelapseChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoAutorecordChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoStabilizationModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoEnableChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateResetHomeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSFixStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSUpdateStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeTypeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateReturnHomeDelayChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (&ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCallback (&ARCONTROLLER_FEATURE_ARDrone3_CameraStateDefaultCameraOrientationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateElectricFrequencyChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSStateNumberOfSatelliteChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeAvailabilityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeChosenChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (&ARCONTROLLER_FEATURE_ARDrone3_PROStateFeaturesCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_UnregisterARCommands (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateLandingModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingFlatTrim (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingFlatTrim</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlatTrim command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingFlatTrim(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingTakeOff (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingTakeOff</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingPCMD (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t flag, int8_t roll, int8_t pitch, int8_t yaw, int8_t gaz, uint32_t timestampAndSeqNum)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, roll, pitch, yaw, gaz, timestampAndSeqNum);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMD (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _flag, int8_t _roll, int8_t _pitch, int8_t _yaw, int8_t _gaz, uint32_t _timestampAndSeqNum)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->roll = _roll;
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;
        feature->privatePart->PilotingPCMDParameters->timestampAndSeqNum = _timestampAndSeqNum;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ARDrone3_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_ARDrone3_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>ARDrone3</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->roll, feature->privatePart->PilotingPCMDParameters->pitch, feature->privatePart->PilotingPCMDParameters->yaw, feature->privatePart->PilotingPCMDParameters->gaz, feature->privatePart->PilotingPCMDParameters->timestampAndSeqNum);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->roll = _roll;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPitch (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _pitch)
{
    // -- Set the pitch for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDYaw (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _yaw)
{
    // -- Set the yaw for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDGaz (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _gaz)
{
    // -- Set the gaz for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDTimestampAndSeqNum (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint32_t _timestampAndSeqNum)
{
    // -- Set the timestampAndSeqNum for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->timestampAndSeqNum = _timestampAndSeqNum;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingLanding (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingLanding</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Landing command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingLanding(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingEmergency (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingEmergency</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Emergency command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingEmergency(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingNavigateHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t start)
{
    // -- Send a command <code>PilotingNavigateHome</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send NavigateHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingNavigateHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingAutoTakeOffMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingAutoTakeOffMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoTakeOffMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingAutoTakeOffMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingMoveBy (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float dX, float dY, float dZ, float dPsi)
{
    // -- Send a command <code>PilotingMoveBy</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MoveBy command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingMoveBy(cmdBuffer, sizeof(cmdBuffer), &cmdSize, dX, dY, dZ, dPsi);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingUserTakeOff (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingUserTakeOff</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserTakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingUserTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingCircle (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION direction)
{
    // -- Send a command <code>PilotingCircle</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Circle command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingCircle(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAnimationsFlip (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION direction)
{
    // -- Send a command <code>AnimationsFlip</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Flip command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AnimationsFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t tilt, int8_t pan)
{
    // -- Send a command <code>CameraOrientation</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Orientation command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, tilt, pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPicture (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordPicture</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideo (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD record, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordVideo</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>MediaRecordVideoV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiScan (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>NetworkWifiScan</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>NetworkWifiAuthChannel</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxAltitude</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxTilt (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxTilt</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxTilt command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxTilt(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsAbsolutControl (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t on)
{
    // -- Send a command <code>PilotingSettingsAbsolutControl</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AbsolutControl command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsAbsolutControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, on);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxDistance (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsMaxDistance</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxDistance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxDistance(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsNoFlyOverMaxDistance (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t shouldNotFlyOver)
{
    // -- Send a command <code>PilotingSettingsNoFlyOverMaxDistance</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send NoFlyOverMaxDistance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsNoFlyOverMaxDistance(cmdBuffer, sizeof(cmdBuffer), &cmdSize, shouldNotFlyOver);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxHorizontalSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxHorizontalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxVerticalSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxHorizontalAcceleration command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxVerticalAcceleration</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxVerticalAcceleration command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAcceleration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxRotationSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsBankedTurn (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t value)
{
    // -- Send a command <code>PilotingSettingsBankedTurn</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send BankedTurn command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsBankedTurn(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMinAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMinAltitude</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MinAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMinAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingDirection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE value)
{
    // -- Send a command <code>PilotingSettingsCirclingDirection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CirclingDirection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsCirclingDirection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingRadius (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t value)
{
    // -- Send a command <code>PilotingSettingsCirclingRadius</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CirclingRadius command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsCirclingRadius(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t value)
{
    // -- Send a command <code>PilotingSettingsCirclingAltitude</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CirclingAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsCirclingAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsPitchMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE value)
{
    // -- Send a command <code>PilotingSettingsPitchMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PitchMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsPitchMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsLandingMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_LANDINGMODE_VALUE value)
{
    // -- Send a command <code>PilotingSettingsLandingMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send LandingMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsLandingMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxVerticalSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxRotationSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsHullProtection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t present)
{
    // -- Send a command <code>SpeedSettingsHullProtection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send HullProtection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsHullProtection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, present);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsOutdoor (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>SpeedSettingsOutdoor</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Outdoor command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsOutdoor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxPitchRollRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxPitchRollRotationSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxPitchRollRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxPitchRollRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>NetworkSettingsWifiSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSecurity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE type, char * key, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE keyType)
{
    // -- Send a command <code>NetworkSettingsWifiSecurity</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSecurity command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkSettingsWifiSecurity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, key, keyType);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsPictureFormatSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE type)
{
    // -- Send a command <code>PictureSettingsPictureFormatSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureFormatSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsPictureFormatSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsAutoWhiteBalanceSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE type)
{
    // -- Send a command <code>PictureSettingsAutoWhiteBalanceSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoWhiteBalanceSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsAutoWhiteBalanceSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsExpositionSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PictureSettingsExpositionSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ExpositionSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsExpositionSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsSaturationSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PictureSettingsSaturationSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SaturationSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsSaturationSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsTimelapseSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enabled, float interval)
{
    // -- Send a command <code>PictureSettingsTimelapseSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TimelapseSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsTimelapseSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled, interval);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoAutorecordSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enabled, uint8_t mass_storage_id)
{
    // -- Send a command <code>PictureSettingsVideoAutorecordSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoAutorecordSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoAutorecordSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoStabilizationMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE mode)
{
    // -- Send a command <code>PictureSettingsVideoStabilizationMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoStabilizationMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoStabilizationMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enable)
{
    // -- Send a command <code>MediaStreamingVideoEnable</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSetHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude)
{
    // -- Send a command <code>GPSSettingsSetHome</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsSetHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsResetHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>GPSSettingsResetHome</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsResetHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSendControllerGPS (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy)
{
    // -- Send a command <code>GPSSettingsSendControllerGPS</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SendControllerGPS command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsSendControllerGPS(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude, horizontalAccuracy, verticalAccuracy);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsHomeType (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE type)
{
    // -- Send a command <code>GPSSettingsHomeType</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send HomeType command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsHomeType(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsReturnHomeDelay (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t delay)
{
    // -- Send a command <code>GPSSettingsReturnHomeDelay</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ReturnHomeDelay command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsReturnHomeDelay(cmdBuffer, sizeof(cmdBuffer), &cmdSize, delay);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringElectricFrequency (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY frequency)
{
    // -- Send a command <code>AntiflickeringElectricFrequency</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ElectricFrequency command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AntiflickeringElectricFrequency(cmdBuffer, sizeof(cmdBuffer), &cmdSize, frequency);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringSetMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE mode)
{
    // -- Send a command <code>AntiflickeringSetMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AntiflickeringSetMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventVideoEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventVideoEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlatTrimChangedCallback (void *customData)
{
    // -- callback used when the command <code>PilotingStateFlatTrimChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLATTRIMCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlatTrimChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlyingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAlertStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateNavigateHomeStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason, void *customData)
{
    // -- callback used when the command <code>PilotingStateNavigateHomeStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateNavigateHomeStateChanged (feature,  _state,  _reason, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePositionChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>PilotingStatePositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStatePositionChanged (feature,  _latitude,  _longitude,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateSpeedChangedCallback (float _speedX, float _speedY, float _speedZ, void *customData)
{
    // -- callback used when the command <code>PilotingStateSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateSpeedChanged (feature,  _speedX,  _speedY,  _speedZ, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAttitudeChangedCallback (float _roll, float _pitch, float _yaw, void *customData)
{
    // -- callback used when the command <code>PilotingStateAttitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAttitudeChanged (feature,  _roll,  _pitch,  _yaw, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAutoTakeOffModeChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAutoTakeOffModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAutoTakeOffModeChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAltitudeChangedCallback (double _altitude, void *customData)
{
    // -- callback used when the command <code>PilotingStateAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAltitudeChanged (feature,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingEventMoveByEndCallback (float _dX, float _dY, float _dZ, float _dPsi, eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PilotingEventMoveByEnd</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingEventMoveByEnd (feature,  _dX,  _dY,  _dZ,  _dPsi,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiScanListChangedCallback (char * _ssid, int16_t _rssi, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiScanListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiScanListChanged (feature,  _ssid,  _rssi,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiScanChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFISCANCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiScanChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxTiltChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxTiltChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxTiltChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAbsolutControlChangedCallback (uint8_t _on, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAbsolutControlChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAbsolutControlChanged (feature,  _on, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxDistanceChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxDistanceChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxDistanceChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (uint8_t _shouldNotFlyOver, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateNoFlyOverMaxDistanceChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateNoFlyOverMaxDistanceChanged (feature,  _shouldNotFlyOver, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxHorizontalSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalSpeed (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxVerticalSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALSPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalSpeed (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxVerticalAcceleration</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalAcceleration (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxRotationSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXROTATIONSPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxRotationSpeed (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateBankedTurnChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateBankedTurnChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateBankedTurnChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMinAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMinAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMinAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingDirectionChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateCirclingDirectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingDirectionChanged (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingRadiusChangedCallback (uint16_t _current, uint16_t _min, uint16_t _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateCirclingRadiusChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingRadiusChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingAltitudeChangedCallback (uint16_t _current, uint16_t _min, uint16_t _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateCirclingAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStatePitchModeChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStatePitchModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStatePitchModeChanged (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateLandingModeChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_LANDINGMODECHANGED_VALUE _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateLandingModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_LANDINGMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateLandingModeChanged (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxVerticalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxVerticalSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateHullProtectionChangedCallback (uint8_t _present, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateHullProtectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateHullProtectionChanged (feature,  _present, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateOutdoorChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateOutdoorChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateOutdoorChanged (feature,  _outdoor, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxPitchRollRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxPitchRollRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSecurityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurityChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE _type, char * _key, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE _keyType, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSecurity</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurity (feature,  _type,  _key,  _keyType, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductMotorVersionListChangedCallback (uint8_t _motor_number, char * _type, char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductMotorVersionListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductMotorVersionListChanged (feature,  _motor_number,  _type,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductGPSVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductGPSVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductGPSVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorStateChangedCallback (uint8_t _motorIds, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorErrorStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorStateChanged (feature,  _motorIds,  _motorError, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorSoftwareVersionChangedCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorSoftwareVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorSoftwareVersionChanged (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorFlightsStatusChangedCallback (uint16_t _nbFlights, uint16_t _lastFlightDuration, uint32_t _totalFlightDuration, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorFlightsStatusChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorFlightsStatusChanged (feature,  _nbFlights,  _lastFlightDuration,  _totalFlightDuration, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorLastErrorChangedCallback (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorErrorLastErrorChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorLastErrorChanged (feature,  _motorError, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateP7IDCallback (char * _serialID, void *customData)
{
    // -- callback used when the command <code>SettingsStateP7ID</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateP7ID (feature,  _serialID, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStatePictureFormatChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStatePictureFormatChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStatePictureFormatChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateAutoWhiteBalanceChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateAutoWhiteBalanceChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateAutoWhiteBalanceChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateExpositionChangedCallback (float _value, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateExpositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateExpositionChanged (feature,  _value,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateSaturationChangedCallback (float _value, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateSaturationChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateSaturationChanged (feature,  _value,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateTimelapseChangedCallback (uint8_t _enabled, float _interval, float _minInterval, float _maxInterval, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateTimelapseChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateTimelapseChanged (feature,  _enabled,  _interval,  _minInterval,  _maxInterval, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoAutorecordChangedCallback (uint8_t _enabled, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoAutorecordChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoAutorecordChanged (feature,  _enabled,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoStabilizationModeChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoStabilizationModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoStabilizationModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>MediaStreamingStateVideoEnableChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaStreamingStateVideoEnableChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateHomeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeChanged (feature,  _latitude,  _longitude,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateResetHomeChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateResetHomeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateResetHomeChanged (feature,  _latitude,  _longitude,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSFixStateChangedCallback (uint8_t _fixed, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateGPSFixStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSFixStateChanged (feature,  _fixed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSUpdateStateChangedCallback (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateGPSUpdateStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSUpdateStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeTypeChangedCallback (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateHomeTypeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeTypeChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateReturnHomeDelayChangedCallback (uint16_t _delay, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateReturnHomeDelayChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateReturnHomeDelayChanged (feature,  _delay, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationCallback (int8_t _tilt, int8_t _pan, void *customData)
{
    // -- callback used when the command <code>CameraStateOrientation</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateOrientation (feature,  _tilt,  _pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateDefaultCameraOrientationCallback (int8_t _tilt, int8_t _pan, void *customData)
{
    // -- callback used when the command <code>CameraStateDefaultCameraOrientation</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateDefaultCameraOrientation (feature,  _tilt,  _pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateElectricFrequencyChangedCallback (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, void *customData)
{
    // -- callback used when the command <code>AntiflickeringStateElectricFrequencyChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateElectricFrequencyChanged (feature,  _frequency, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateModeChangedCallback (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>AntiflickeringStateModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateNumberOfSatelliteChangedCallback (uint8_t _numberOfSatellite, void *customData)
{
    // -- callback used when the command <code>GPSStateNumberOfSatelliteChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSStateNumberOfSatelliteChanged (feature,  _numberOfSatellite, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeAvailabilityChangedCallback (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type, uint8_t _available, void *customData)
{
    // -- callback used when the command <code>GPSStateHomeTypeAvailabilityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeAvailabilityChanged (feature,  _type,  _available, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeChosenChangedCallback (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>GPSStateHomeTypeChosenChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeChosenChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PROStateFeaturesCallback (uint64_t _features, void *customData)
{
    // -- callback used when the command <code>PROStateFeatures</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPROStateFeatures (feature,  _features, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChangedV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventVideoEventChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventVideoEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlatTrimChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlatTrimChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlyingStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateNavigateHomeStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateNavigateHomeStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON;
            argDictNewElement->value.I32 = _reason;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStatePositionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _speedX, float _speedY, float _speedZ, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX;
            argDictNewElement->value.Float = _speedX;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY;
            argDictNewElement->value.Float = _speedY;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ;
            argDictNewElement->value.Float = _speedZ;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAttitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _roll, float _pitch, float _yaw, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAttitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL;
            argDictNewElement->value.Float = _roll;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH;
            argDictNewElement->value.Float = _pitch;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW;
            argDictNewElement->value.Float = _yaw;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAutoTakeOffModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAutoTakeOffModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingEventMoveByEnd (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _dX, float _dY, float _dZ, float _dPsi, eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingEventMoveByEnd -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DX;
            argDictNewElement->value.Float = _dX;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DY;
            argDictNewElement->value.Float = _dY;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DZ;
            argDictNewElement->value.Float = _dZ;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DPSI;
            argDictNewElement->value.Float = _dPsi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiScanListChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, char * _ssid, int16_t _rssi, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiScanListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiScanChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiScanChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxTiltChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxTiltChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAbsolutControlChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _on, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAbsolutControlChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON;
            argDictNewElement->value.U8 = _on;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxDistanceChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxDistanceChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateNoFlyOverMaxDistanceChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _shouldNotFlyOver, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateNoFlyOverMaxDistanceChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER;
            argDictNewElement->value.U8 = _shouldNotFlyOver;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxHorizontalSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxVerticalSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALSPEED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxVerticalAcceleration -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxRotationSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXROTATIONSPEED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateBankedTurnChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateBankedTurnChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMinAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMinAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingDirectionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateCirclingDirectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingRadiusChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _current, uint16_t _min, uint16_t _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateCirclingRadiusChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_CURRENT;
            argDictNewElement->value.U16 = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MIN;
            argDictNewElement->value.U16 = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MAX;
            argDictNewElement->value.U16 = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _current, uint16_t _min, uint16_t _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateCirclingAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_CURRENT;
            argDictNewElement->value.U16 = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MIN;
            argDictNewElement->value.U16 = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MAX;
            argDictNewElement->value.U16 = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStatePitchModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStatePitchModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateLandingModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_LANDINGMODECHANGED_VALUE _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateLandingModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_LANDINGMODECHANGED_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxVerticalSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateHullProtectionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _present, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateHullProtectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT;
            argDictNewElement->value.U8 = _present;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateOutdoorChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _outdoor, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateOutdoorChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxPitchRollRotationSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxPitchRollRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurityChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSecurityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE _type, char * _key, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE _keyType, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSecurity -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEY;
            strLength = strlen (_key);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _key, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE;
            argDictNewElement->value.I32 = _keyType;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductMotorVersionListChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _motor_number, char * _type, char * _software, char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductMotorVersionListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _motor_number);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _motor_number);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_MOTOR_NUMBER;
            argDictNewElement->value.U8 = _motor_number;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_TYPE;
            strLength = strlen (_type);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _type, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductGPSVersionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, char * _software, char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductGPSVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _motorIds, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorErrorStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORIDS;
            argDictNewElement->value.U8 = _motorIds;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR;
            argDictNewElement->value.I32 = _motorError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorSoftwareVersionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorSoftwareVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorFlightsStatusChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _nbFlights, uint16_t _lastFlightDuration, uint32_t _totalFlightDuration, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorFlightsStatusChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_NBFLIGHTS;
            argDictNewElement->value.U16 = _nbFlights;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_LASTFLIGHTDURATION;
            argDictNewElement->value.U16 = _lastFlightDuration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_TOTALFLIGHTDURATION;
            argDictNewElement->value.U32 = _totalFlightDuration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorLastErrorChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorErrorLastErrorChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR;
            argDictNewElement->value.I32 = _motorError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateP7ID (ARCONTROLLER_FEATURE_ARDrone3_t *feature, char * _serialID, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateP7ID -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID_SERIALID;
            strLength = strlen (_serialID);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serialID, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStatePictureFormatChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStatePictureFormatChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateAutoWhiteBalanceChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateAutoWhiteBalanceChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateExpositionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateExpositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateSaturationChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateSaturationChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateTimelapseChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _enabled, float _interval, float _minInterval, float _maxInterval, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateTimelapseChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_INTERVAL;
            argDictNewElement->value.Float = _interval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MININTERVAL;
            argDictNewElement->value.Float = _minInterval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MAXINTERVAL;
            argDictNewElement->value.Float = _maxInterval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoAutorecordChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _enabled, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoAutorecordChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoStabilizationModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoStabilizationModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaStreamingStateVideoEnableChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaStreamingStateVideoEnableChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateHomeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateResetHomeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateResetHomeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSFixStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _fixed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateGPSFixStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED_FIXED;
            argDictNewElement->value.U8 = _fixed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSUpdateStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateGPSUpdateStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeTypeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateHomeTypeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateReturnHomeDelayChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _delay, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateReturnHomeDelayChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY;
            argDictNewElement->value.U16 = _delay;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _tilt, int8_t _pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateOrientation -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT;
            argDictNewElement->value.I8 = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN;
            argDictNewElement->value.I8 = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateDefaultCameraOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _tilt, int8_t _pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateDefaultCameraOrientation -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_TILT;
            argDictNewElement->value.I8 = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_PAN;
            argDictNewElement->value.I8 = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateElectricFrequencyChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AntiflickeringStateElectricFrequencyChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AntiflickeringStateModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSStateNumberOfSatelliteChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _numberOfSatellite, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSStateNumberOfSatelliteChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE;
            argDictNewElement->value.U8 = _numberOfSatellite;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeAvailabilityChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type, uint8_t _available, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSStateHomeTypeAvailabilityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _type);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _type);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE;
            argDictNewElement->value.U8 = _available;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeChosenChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSStateHomeTypeChosenChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPROStateFeatures (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint64_t _features, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PROStateFeatures -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES;
            argDictNewElement->value.U64 = _features;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetNetworkController (ARCONTROLLER_FEATURE_ARDrone3_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_GetCommandElements (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE common --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE = "arcontroller_dictionary_key_common_networkevent_disconnection_cause";



const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED_NAME = "arcontroller_dictionary_key_common_settingsstate_productnamechanged_name";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_common_settingsstate_productversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_common_settingsstate_productversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED_HIGH = "arcontroller_dictionary_key_common_settingsstate_productserialhighchanged_high";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED_LOW = "arcontroller_dictionary_key_common_settingsstate_productseriallowchanged_low";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED_CODE = "arcontroller_dictionary_key_common_settingsstate_countrychanged_code";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED_AUTOMATIC = "arcontroller_dictionary_key_common_settingsstate_autocountrychanged_automatic";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT = "arcontroller_dictionary_key_common_commonstate_batterystatechanged_percent";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstoragestatelistchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME = "arcontroller_dictionary_key_common_commonstate_massstoragestatelistchanged_name";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_size";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_used_size";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_plugged";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_full";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_internal";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE = "arcontroller_dictionary_key_common_commonstate_currentdatechanged_date";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME = "arcontroller_dictionary_key_common_commonstate_currenttimechanged_time";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_free_space";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_rec_time";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_photo_remaining";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI = "arcontroller_dictionary_key_common_commonstate_wifisignalchanged_rssi";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME = "arcontroller_dictionary_key_common_commonstate_sensorsstateslistchanged_sensorname";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE = "arcontroller_dictionary_key_common_commonstate_sensorsstateslistchanged_sensorstate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL = "arcontroller_dictionary_key_common_commonstate_productmodel_model";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_LISTFLAGS = "arcontroller_dictionary_key_common_commonstate_countrylistknown_listflags";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_COUNTRYCODES = "arcontroller_dictionary_key_common_commonstate_countrylistknown_countrycodes";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE = "arcontroller_dictionary_key_common_overheatstate_overheatregulationchanged_regulationtype";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED_OUTDOOR = "arcontroller_dictionary_key_common_wifisettingsstate_outdoorsettingschanged_outdoor";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_filepath";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkplayerrorstatechanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_xaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_yaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_zaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_calibrationfailed";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationrequiredstate_required";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationaxistocalibratechanged_axis";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstartedchanged_started";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_FOV = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_fov";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMAX = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_panmax";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMIN = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_panmin";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMAX = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_tiltmax";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMIN = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_tiltmin";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE = "arcontroller_dictionary_key_common_flightplanstate_availabilitystatechanged_availabilitystate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT = "arcontroller_dictionary_key_common_flightplanstate_componentstatelistchanged_component";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE = "arcontroller_dictionary_key_common_flightplanstate_componentstatelistchanged_state";



const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_controllerlibarcommandsversion_version";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_skycontrollerlibarcommandsversion_version";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_devicelibarcommandsversion_version";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING_RUNNING = "arcontroller_dictionary_key_common_audiostate_audiostreamingrunning_running";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_LEFT = "arcontroller_dictionary_key_common_headlightsstate_intensitychanged_left";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_RIGHT = "arcontroller_dictionary_key_common_headlightsstate_intensitychanged_right";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ANIM = "arcontroller_dictionary_key_common_animationsstate_list_anim";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_STATE = "arcontroller_dictionary_key_common_animationsstate_list_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ERROR = "arcontroller_dictionary_key_common_animationsstate_list_error";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY = "arcontroller_dictionary_key_common_accessorystate_supportedaccessorieslistchanged_accessory";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY = "arcontroller_dictionary_key_common_accessorystate_accessoryconfigchanged_newaccessory";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR = "arcontroller_dictionary_key_common_accessorystate_accessoryconfigchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED_ENABLED = "arcontroller_dictionary_key_common_accessorystate_accessoryconfigmodificationenabled_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE = "arcontroller_dictionary_key_common_chargerstate_maxchargeratechanged_rate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS = "arcontroller_dictionary_key_common_chargerstate_currentchargestatechanged_status";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE = "arcontroller_dictionary_key_common_chargerstate_currentchargestatechanged_phase";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE = "arcontroller_dictionary_key_common_chargerstate_lastchargeratechanged_rate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE = "arcontroller_dictionary_key_common_chargerstate_charginginfo_phase";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_RATE = "arcontroller_dictionary_key_common_chargerstate_charginginfo_rate";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_INTENSITY = "arcontroller_dictionary_key_common_chargerstate_charginginfo_intensity";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_FULLCHARGINGTIME = "arcontroller_dictionary_key_common_chargerstate_charginginfo_fullchargingtime";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_RUNSTATE_RUNIDCHANGED_RUNID = "arcontroller_dictionary_key_common_runstate_runidchanged_runid";

ARCONTROLLER_FEATURE_Common_t *ARCONTROLLER_FEATURE_Common_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Common_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Common_t));
        if (featureController != NULL)
        {
            featureController->sendNetworkDisconnect = ARCONTROLLER_FEATURE_Common_SendNetworkDisconnect;
            featureController->sendSettingsAllSettings = ARCONTROLLER_FEATURE_Common_SendSettingsAllSettings;
            featureController->sendSettingsReset = ARCONTROLLER_FEATURE_Common_SendSettingsReset;
            featureController->sendSettingsProductName = ARCONTROLLER_FEATURE_Common_SendSettingsProductName;
            featureController->sendSettingsCountry = ARCONTROLLER_FEATURE_Common_SendSettingsCountry;
            featureController->sendSettingsAutoCountry = ARCONTROLLER_FEATURE_Common_SendSettingsAutoCountry;
            featureController->sendCommonAllStates = ARCONTROLLER_FEATURE_Common_SendCommonAllStates;
            featureController->sendCommonCurrentDate = ARCONTROLLER_FEATURE_Common_SendCommonCurrentDate;
            featureController->sendCommonCurrentTime = ARCONTROLLER_FEATURE_Common_SendCommonCurrentTime;
            featureController->sendCommonReboot = ARCONTROLLER_FEATURE_Common_SendCommonReboot;
            featureController->sendOverHeatSwitchOff = ARCONTROLLER_FEATURE_Common_SendOverHeatSwitchOff;
            featureController->sendOverHeatVentilate = ARCONTROLLER_FEATURE_Common_SendOverHeatVentilate;
            featureController->sendControllerIsPiloting = ARCONTROLLER_FEATURE_Common_SendControllerIsPiloting;
            featureController->sendWifiSettingsOutdoorSetting = ARCONTROLLER_FEATURE_Common_SendWifiSettingsOutdoorSetting;
            featureController->sendMavlinkStart = ARCONTROLLER_FEATURE_Common_SendMavlinkStart;
            featureController->sendMavlinkPause = ARCONTROLLER_FEATURE_Common_SendMavlinkPause;
            featureController->sendMavlinkStop = ARCONTROLLER_FEATURE_Common_SendMavlinkStop;
            featureController->sendCalibrationMagnetoCalibration = ARCONTROLLER_FEATURE_Common_SendCalibrationMagnetoCalibration;
            featureController->sendGPSControllerPositionForRun = ARCONTROLLER_FEATURE_Common_SendGPSControllerPositionForRun;
            featureController->sendAudioControllerReadyForStreaming = ARCONTROLLER_FEATURE_Common_SendAudioControllerReadyForStreaming;
            featureController->sendHeadlightsIntensity = ARCONTROLLER_FEATURE_Common_SendHeadlightsIntensity;
            featureController->sendAnimationsStartAnimation = ARCONTROLLER_FEATURE_Common_SendAnimationsStartAnimation;
            featureController->sendAnimationsStopAnimation = ARCONTROLLER_FEATURE_Common_SendAnimationsStopAnimation;
            featureController->sendAnimationsStopAllAnimations = ARCONTROLLER_FEATURE_Common_SendAnimationsStopAllAnimations;
            featureController->sendAccessoryConfig = ARCONTROLLER_FEATURE_Common_SendAccessoryConfig;
            featureController->sendChargerSetMaxChargeRate = ARCONTROLLER_FEATURE_Common_SendChargerSetMaxChargeRate;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Common_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_Common_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Common_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Common_Delete (ARCONTROLLER_FEATURE_Common_t **feature)
{
    // -- Delete the common feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_Common_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Common_GetDictionary (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the common Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_AddCallback (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Common</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_RemoveCallback (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Common</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_RegisterARCommands (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (&ARCONTROLLER_FEATURE_Common_NetworkEventDisconnectionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateAllSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateResetChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductNameChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialHighChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialLowChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateCountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateAutoCountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateAllStatesChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateBatteryStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateMassStorageStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateCurrentDateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateCurrentTimeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoRemainingListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateWifiSignalChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateSensorsStatesListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCallback (&ARCONTROLLER_FEATURE_Common_CommonStateProductModelCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCallback (&ARCONTROLLER_FEATURE_Common_CommonStateCountryListKnownCallback, feature);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (&ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (&ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatRegulationChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (&ARCONTROLLER_FEATURE_Common_WifiSettingsStateOutdoorSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (&ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkFilePlayingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (&ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkPlayErrorStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationRequiredStateCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStartedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (&ARCONTROLLER_FEATURE_Common_CameraSettingsStateCameraSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanStateAvailabilityStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanStateComponentStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanEventStartingErrorEventCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanEventSpeedBridleEventCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (&ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateControllerLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (&ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateSkyControllerLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (&ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateDeviceLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCallback (&ARCONTROLLER_FEATURE_Common_AudioStateAudioStreamingRunningCallback, feature);
        ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCallback (&ARCONTROLLER_FEATURE_Common_HeadlightsStateIntensityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAnimationsStateListCallback (&ARCONTROLLER_FEATURE_Common_AnimationsStateListCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCallback (&ARCONTROLLER_FEATURE_Common_AccessoryStateSupportedAccessoriesListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCallback (&ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCallback (&ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigModificationEnabledCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCallback (&ARCONTROLLER_FEATURE_Common_ChargerStateMaxChargeRateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCallback (&ARCONTROLLER_FEATURE_Common_ChargerStateCurrentChargeStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCallback (&ARCONTROLLER_FEATURE_Common_ChargerStateLastChargeRateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCallback (&ARCONTROLLER_FEATURE_Common_ChargerStateChargingInfoCallback, feature);
        ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCallback (&ARCONTROLLER_FEATURE_Common_RunStateRunIdChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_UnregisterARCommands (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAnimationsStateListCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendNetworkDisconnect (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>NetworkDisconnect</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Disconnect command
        cmdError = ARCOMMANDS_Generator_GenerateCommonNetworkDisconnect(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsAllSettings (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>SettingsAllSettings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsReset (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>SettingsReset</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsProductName (ARCONTROLLER_FEATURE_Common_t *feature, char * name)
{
    // -- Send a command <code>SettingsProductName</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ProductName command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsProductName(cmdBuffer, sizeof(cmdBuffer), &cmdSize, name);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsCountry (ARCONTROLLER_FEATURE_Common_t *feature, char * code)
{
    // -- Send a command <code>SettingsCountry</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Country command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, code);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsAutoCountry (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t automatic)
{
    // -- Send a command <code>SettingsAutoCountry</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoCountry command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsAutoCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, automatic);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonAllStates (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>CommonAllStates</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllStates command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonAllStates(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonCurrentDate (ARCONTROLLER_FEATURE_Common_t *feature, char * date)
{
    // -- Send a command <code>CommonCurrentDate</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CurrentDate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonCurrentDate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, date);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonCurrentTime (ARCONTROLLER_FEATURE_Common_t *feature, char * time)
{
    // -- Send a command <code>CommonCurrentTime</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CurrentTime command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonCurrentTime(cmdBuffer, sizeof(cmdBuffer), &cmdSize, time);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonReboot (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>CommonReboot</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reboot command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonReboot(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendOverHeatSwitchOff (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>OverHeatSwitchOff</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SwitchOff command
        cmdError = ARCOMMANDS_Generator_GenerateCommonOverHeatSwitchOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendOverHeatVentilate (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>OverHeatVentilate</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Ventilate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonOverHeatVentilate(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendControllerIsPiloting (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t piloting)
{
    // -- Send a command <code>ControllerIsPiloting</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send IsPiloting command
        cmdError = ARCOMMANDS_Generator_GenerateCommonControllerIsPiloting(cmdBuffer, sizeof(cmdBuffer), &cmdSize, piloting);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendWifiSettingsOutdoorSetting (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>WifiSettingsOutdoorSetting</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send OutdoorSetting command
        cmdError = ARCOMMANDS_Generator_GenerateCommonWifiSettingsOutdoorSetting(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkStart (ARCONTROLLER_FEATURE_Common_t *feature, char * filepath, eARCOMMANDS_COMMON_MAVLINK_START_TYPE type)
{
    // -- Send a command <code>MavlinkStart</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Start command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkStart(cmdBuffer, sizeof(cmdBuffer), &cmdSize, filepath, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkPause (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>MavlinkPause</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Pause command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkPause(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkStop (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>MavlinkStop</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Stop command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCalibrationMagnetoCalibration (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t calibrate)
{
    // -- Send a command <code>CalibrationMagnetoCalibration</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MagnetoCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCalibrationMagnetoCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, calibrate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendGPSControllerPositionForRun (ARCONTROLLER_FEATURE_Common_t *feature, double latitude, double longitude)
{
    // -- Send a command <code>GPSControllerPositionForRun</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerPositionForRun command
        cmdError = ARCOMMANDS_Generator_GenerateCommonGPSControllerPositionForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAudioControllerReadyForStreaming (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t ready)
{
    // -- Send a command <code>AudioControllerReadyForStreaming</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerReadyForStreaming command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAudioControllerReadyForStreaming(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ready);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendHeadlightsIntensity (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t left, uint8_t right)
{
    // -- Send a command <code>HeadlightsIntensity</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Intensity command
        cmdError = ARCOMMANDS_Generator_GenerateCommonHeadlightsIntensity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, left, right);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAnimationsStartAnimation (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM anim)
{
    // -- Send a command <code>AnimationsStartAnimation</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAnimationsStartAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, anim);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAnimationsStopAnimation (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM anim)
{
    // -- Send a command <code>AnimationsStopAnimation</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAnimationsStopAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, anim);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAnimationsStopAllAnimations (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>AnimationsStopAllAnimations</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopAllAnimations command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAnimationsStopAllAnimations(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAccessoryConfig (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY accessory)
{
    // -- Send a command <code>AccessoryConfig</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Config command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAccessoryConfig(cmdBuffer, sizeof(cmdBuffer), &cmdSize, accessory);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendChargerSetMaxChargeRate (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE rate)
{
    // -- Send a command <code>ChargerSetMaxChargeRate</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetMaxChargeRate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonChargerSetMaxChargeRate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, rate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Common_NetworkEventDisconnectionCallback (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause, void *customData)
{
    // -- callback used when the command <code>NetworkEventDisconnection</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementNetworkEventDisconnection (feature,  _cause, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateAllSettingsChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateAllSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_ALLSETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateAllSettingsChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateResetChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateResetChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_RESETCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateResetChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductNameChangedCallback (char * _name, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductNameChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductNameChanged (feature,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialHighChangedCallback (char * _high, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductSerialHighChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialHighChanged (feature,  _high, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialLowChangedCallback (char * _low, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductSerialLowChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialLowChanged (feature,  _low, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateCountryChangedCallback (char * _code, void *customData)
{
    // -- callback used when the command <code>SettingsStateCountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateCountryChanged (feature,  _code, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateAutoCountryChangedCallback (uint8_t _automatic, void *customData)
{
    // -- callback used when the command <code>SettingsStateAutoCountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateAutoCountryChanged (feature,  _automatic, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateAllStatesChangedCallback (void *customData)
{
    // -- callback used when the command <code>CommonStateAllStatesChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_ALLSTATESCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateAllStatesChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateBatteryStateChangedCallback (uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>CommonStateBatteryStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateBatteryStateChanged (feature,  _percent, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageStateListChangedCallback (uint8_t _mass_storage_id, char * _name, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageStateListChanged (feature,  _mass_storage_id,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoStateListChangedCallback (uint8_t _mass_storage_id, uint32_t _size, uint32_t _used_size, uint8_t _plugged, uint8_t _full, uint8_t _internal, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageInfoStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoStateListChanged (feature,  _mass_storage_id,  _size,  _used_size,  _plugged,  _full,  _internal, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateCurrentDateChangedCallback (char * _date, void *customData)
{
    // -- callback used when the command <code>CommonStateCurrentDateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateCurrentDateChanged (feature,  _date, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateCurrentTimeChangedCallback (char * _time, void *customData)
{
    // -- callback used when the command <code>CommonStateCurrentTimeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateCurrentTimeChanged (feature,  _time, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoRemainingListChangedCallback (uint32_t _free_space, uint16_t _rec_time, uint32_t _photo_remaining, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageInfoRemainingListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoRemainingListChanged (feature,  _free_space,  _rec_time,  _photo_remaining, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateWifiSignalChangedCallback (int16_t _rssi, void *customData)
{
    // -- callback used when the command <code>CommonStateWifiSignalChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateWifiSignalChanged (feature,  _rssi, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateSensorsStatesListChangedCallback (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName, uint8_t _sensorState, void *customData)
{
    // -- callback used when the command <code>CommonStateSensorsStatesListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateSensorsStatesListChanged (feature,  _sensorName,  _sensorState, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateProductModelCallback (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL _model, void *customData)
{
    // -- callback used when the command <code>CommonStateProductModel</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateProductModel (feature,  _model, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateCountryListKnownCallback (uint8_t _listFlags, char * _countryCodes, void *customData)
{
    // -- callback used when the command <code>CommonStateCountryListKnown</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateCountryListKnown (feature,  _listFlags,  _countryCodes, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatChangedCallback (void *customData)
{
    // -- callback used when the command <code>OverHeatStateOverHeatChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatRegulationChangedCallback (uint8_t _regulationType, void *customData)
{
    // -- callback used when the command <code>OverHeatStateOverHeatRegulationChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatRegulationChanged (feature,  _regulationType, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_WifiSettingsStateOutdoorSettingsChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>WifiSettingsStateOutdoorSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementWifiSettingsStateOutdoorSettingsChanged (feature,  _outdoor, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkFilePlayingStateChangedCallback (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state, char * _filepath, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>MavlinkStateMavlinkFilePlayingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkFilePlayingStateChanged (feature,  _state,  _filepath,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkPlayErrorStateChangedCallback (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MavlinkStateMavlinkPlayErrorStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkPlayErrorStateChanged (feature,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStateChangedCallback (uint8_t _xAxisCalibration, uint8_t _yAxisCalibration, uint8_t _zAxisCalibration, uint8_t _calibrationFailed, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStateChanged (feature,  _xAxisCalibration,  _yAxisCalibration,  _zAxisCalibration,  _calibrationFailed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationRequiredStateCallback (uint8_t _required, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationRequiredState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationRequiredState (feature,  _required, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationAxisToCalibrateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationAxisToCalibrateChanged (feature,  _axis, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStartedChangedCallback (uint8_t _started, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationStartedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStartedChanged (feature,  _started, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CameraSettingsStateCameraSettingsChangedCallback (float _fov, float _panMax, float _panMin, float _tiltMax, float _tiltMin, void *customData)
{
    // -- callback used when the command <code>CameraSettingsStateCameraSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCameraSettingsStateCameraSettingsChanged (feature,  _fov,  _panMax,  _panMin,  _tiltMax,  _tiltMin, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanStateAvailabilityStateChangedCallback (uint8_t _AvailabilityState, void *customData)
{
    // -- callback used when the command <code>FlightPlanStateAvailabilityStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanStateAvailabilityStateChanged (feature,  _AvailabilityState, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanStateComponentStateListChangedCallback (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component, uint8_t _State, void *customData)
{
    // -- callback used when the command <code>FlightPlanStateComponentStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanStateComponentStateListChanged (feature,  _component,  _State, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanEventStartingErrorEventCallback (void *customData)
{
    // -- callback used when the command <code>FlightPlanEventStartingErrorEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANEVENT_STARTINGERROREVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanEventStartingErrorEvent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanEventSpeedBridleEventCallback (void *customData)
{
    // -- callback used when the command <code>FlightPlanEventSpeedBridleEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANEVENT_SPEEDBRIDLEEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanEventSpeedBridleEvent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateControllerLibARCommandsVersionCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>ARLibsVersionsStateControllerLibARCommandsVersion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateControllerLibARCommandsVersion (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>ARLibsVersionsStateSkyControllerLibARCommandsVersion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateSkyControllerLibARCommandsVersion (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateDeviceLibARCommandsVersionCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>ARLibsVersionsStateDeviceLibARCommandsVersion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateDeviceLibARCommandsVersion (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AudioStateAudioStreamingRunningCallback (uint8_t _running, void *customData)
{
    // -- callback used when the command <code>AudioStateAudioStreamingRunning</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAudioStateAudioStreamingRunning (feature,  _running, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_HeadlightsStateIntensityChangedCallback (uint8_t _left, uint8_t _right, void *customData)
{
    // -- callback used when the command <code>HeadlightsStateIntensityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementHeadlightsStateIntensityChanged (feature,  _left,  _right, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AnimationsStateListCallback (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM _anim, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE _state, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR _error, void *customData)
{
    // -- callback used when the command <code>AnimationsStateList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAnimationsStateList (feature,  _anim,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AccessoryStateSupportedAccessoriesListChangedCallback (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY _accessory, void *customData)
{
    // -- callback used when the command <code>AccessoryStateSupportedAccessoriesListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAccessoryStateSupportedAccessoriesListChanged (feature,  _accessory, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigChangedCallback (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY _newAccessory, eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>AccessoryStateAccessoryConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigChanged (feature,  _newAccessory,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigModificationEnabledCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>AccessoryStateAccessoryConfigModificationEnabled</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigModificationEnabled (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateMaxChargeRateChangedCallback (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE _rate, void *customData)
{
    // -- callback used when the command <code>ChargerStateMaxChargeRateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateMaxChargeRateChanged (feature,  _rate, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateCurrentChargeStateChangedCallback (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS _status, eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE _phase, void *customData)
{
    // -- callback used when the command <code>ChargerStateCurrentChargeStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateCurrentChargeStateChanged (feature,  _status,  _phase, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateLastChargeRateChangedCallback (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE _rate, void *customData)
{
    // -- callback used when the command <code>ChargerStateLastChargeRateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateLastChargeRateChanged (feature,  _rate, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateChargingInfoCallback (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE _phase, eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE _rate, uint8_t _intensity, uint8_t _fullChargingTime, void *customData)
{
    // -- callback used when the command <code>ChargerStateChargingInfo</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateChargingInfo (feature,  _phase,  _rate,  _intensity,  _fullChargingTime, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_RunStateRunIdChangedCallback (char * _runId, void *customData)
{
    // -- callback used when the command <code>RunStateRunIdChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_RUNSTATE_RUNIDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementRunStateRunIdChanged (feature,  _runId, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementNetworkEventDisconnection (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkEventDisconnection -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE;
            argDictNewElement->value.I32 = _cause;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateAllSettingsChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateAllSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateResetChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateResetChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductNameChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductNameChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductVersionChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _software, char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialHighChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _high, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductSerialHighChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED_HIGH;
            strLength = strlen (_high);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _high, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialLowChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _low, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductSerialLowChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED_LOW;
            strLength = strlen (_low);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _low, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateCountryChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _code, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateCountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED_CODE;
            strLength = strlen (_code);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _code, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateAutoCountryChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _automatic, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateAutoCountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED_AUTOMATIC;
            argDictNewElement->value.U8 = _automatic;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateAllStatesChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateAllStatesChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateBatteryStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _percent, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateBatteryStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageStateListChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoStateListChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, uint32_t _size, uint32_t _used_size, uint8_t _plugged, uint8_t _full, uint8_t _internal, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageInfoStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE;
            argDictNewElement->value.U32 = _size;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE;
            argDictNewElement->value.U32 = _used_size;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED;
            argDictNewElement->value.U8 = _plugged;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL;
            argDictNewElement->value.U8 = _full;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL;
            argDictNewElement->value.U8 = _internal;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateCurrentDateChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _date, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateCurrentDateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE;
            strLength = strlen (_date);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _date, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateCurrentTimeChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _time, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateCurrentTimeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME;
            strLength = strlen (_time);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _time, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoRemainingListChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint32_t _free_space, uint16_t _rec_time, uint32_t _photo_remaining, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageInfoRemainingListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE;
            argDictNewElement->value.U32 = _free_space;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME;
            argDictNewElement->value.U16 = _rec_time;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING;
            argDictNewElement->value.U32 = _photo_remaining;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateWifiSignalChanged (ARCONTROLLER_FEATURE_Common_t *feature, int16_t _rssi, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateWifiSignalChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateSensorsStatesListChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName, uint8_t _sensorState, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateSensorsStatesListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _sensorName);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _sensorName);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME;
            argDictNewElement->value.I32 = _sensorName;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE;
            argDictNewElement->value.U8 = _sensorState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateProductModel (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL _model, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateProductModel -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL;
            argDictNewElement->value.I32 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateCountryListKnown (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _listFlags, char * _countryCodes, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateCountryListKnown -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_LISTFLAGS;
            argDictNewElement->value.U8 = _listFlags;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_COUNTRYCODES;
            strLength = strlen (_countryCodes);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _countryCodes, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event OverHeatStateOverHeatChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatRegulationChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _regulationType, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event OverHeatStateOverHeatRegulationChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE;
            argDictNewElement->value.U8 = _regulationType;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementWifiSettingsStateOutdoorSettingsChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _outdoor, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiSettingsStateOutdoorSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkFilePlayingStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state, char * _filepath, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MavlinkStateMavlinkFilePlayingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH;
            strLength = strlen (_filepath);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filepath, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkPlayErrorStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MavlinkStateMavlinkPlayErrorStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _xAxisCalibration, uint8_t _yAxisCalibration, uint8_t _zAxisCalibration, uint8_t _calibrationFailed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION;
            argDictNewElement->value.U8 = _xAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION;
            argDictNewElement->value.U8 = _yAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION;
            argDictNewElement->value.U8 = _zAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED;
            argDictNewElement->value.U8 = _calibrationFailed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationRequiredState (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _required, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationRequiredState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED;
            argDictNewElement->value.U8 = _required;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationAxisToCalibrateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationAxisToCalibrateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS;
            argDictNewElement->value.I32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStartedChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _started, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationStartedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED;
            argDictNewElement->value.U8 = _started;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCameraSettingsStateCameraSettingsChanged (ARCONTROLLER_FEATURE_Common_t *feature, float _fov, float _panMax, float _panMin, float _tiltMax, float _tiltMin, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraSettingsStateCameraSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_FOV;
            argDictNewElement->value.Float = _fov;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMAX;
            argDictNewElement->value.Float = _panMax;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMIN;
            argDictNewElement->value.Float = _panMin;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMAX;
            argDictNewElement->value.Float = _tiltMax;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMIN;
            argDictNewElement->value.Float = _tiltMin;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanStateAvailabilityStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _AvailabilityState, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanStateAvailabilityStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE;
            argDictNewElement->value.U8 = _AvailabilityState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanStateComponentStateListChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component, uint8_t _State, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanStateComponentStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _component);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _component);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT;
            argDictNewElement->value.I32 = _component;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE;
            argDictNewElement->value.U8 = _State;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanEventStartingErrorEvent (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanEventStartingErrorEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanEventSpeedBridleEvent (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanEventSpeedBridleEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateControllerLibARCommandsVersion (ARCONTROLLER_FEATURE_Common_t *feature, char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ARLibsVersionsStateControllerLibARCommandsVersion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateSkyControllerLibARCommandsVersion (ARCONTROLLER_FEATURE_Common_t *feature, char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ARLibsVersionsStateSkyControllerLibARCommandsVersion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateDeviceLibARCommandsVersion (ARCONTROLLER_FEATURE_Common_t *feature, char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ARLibsVersionsStateDeviceLibARCommandsVersion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAudioStateAudioStreamingRunning (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _running, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AudioStateAudioStreamingRunning -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING_RUNNING;
            argDictNewElement->value.U8 = _running;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementHeadlightsStateIntensityChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _left, uint8_t _right, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event HeadlightsStateIntensityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_LEFT;
            argDictNewElement->value.U8 = _left;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_RIGHT;
            argDictNewElement->value.U8 = _right;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAnimationsStateList (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM _anim, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE _state, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _anim);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _anim);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ANIM;
            argDictNewElement->value.I32 = _anim;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAccessoryStateSupportedAccessoriesListChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY _accessory, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateSupportedAccessoriesListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _accessory);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _accessory);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY;
            argDictNewElement->value.I32 = _accessory;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY _newAccessory, eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateAccessoryConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY;
            argDictNewElement->value.I32 = _newAccessory;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigModificationEnabled (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateAccessoryConfigModificationEnabled -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateMaxChargeRateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE _rate, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateMaxChargeRateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE;
            argDictNewElement->value.I32 = _rate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateCurrentChargeStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS _status, eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE _phase, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateCurrentChargeStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE;
            argDictNewElement->value.I32 = _phase;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateLastChargeRateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE _rate, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateLastChargeRateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE;
            argDictNewElement->value.I32 = _rate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateChargingInfo (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE _phase, eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE _rate, uint8_t _intensity, uint8_t _fullChargingTime, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateChargingInfo -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE;
            argDictNewElement->value.I32 = _phase;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_RATE;
            argDictNewElement->value.I32 = _rate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_INTENSITY;
            argDictNewElement->value.U8 = _intensity;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_FULLCHARGINGTIME;
            argDictNewElement->value.U8 = _fullChargingTime;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementRunStateRunIdChanged (ARCONTROLLER_FEATURE_Common_t *feature, char * _runId, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RunStateRunIdChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_RUNSTATE_RUNIDCHANGED_RUNID;
            strLength = strlen (_runId);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _runId, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SetNetworkController (ARCONTROLLER_FEATURE_Common_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_GetCommandElements (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE commonDebug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_STATSEVENT_SENDPACKET_PACKET = "arcontroller_dictionary_key_commondebug_statsevent_sendpacket_packet";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_LISTFLAGS = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_listflags";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_ID = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_LABEL = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_label";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_TYPE = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_type";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_MODE = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_RANGE_MIN = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_range_min";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_RANGE_MAX = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_range_max";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_RANGE_STEP = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_range_step";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_VALUE = "arcontroller_dictionary_key_commondebug_debugsettingsstate_info_value";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_LISTCHANGED_ID = "arcontroller_dictionary_key_commondebug_debugsettingsstate_listchanged_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_LISTCHANGED_VALUE = "arcontroller_dictionary_key_commondebug_debugsettingsstate_listchanged_value";

ARCONTROLLER_FEATURE_CommonDebug_t *ARCONTROLLER_FEATURE_CommonDebug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_CommonDebug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_CommonDebug_t));
        if (featureController != NULL)
        {
            featureController->sendStatsSendPacket = ARCONTROLLER_FEATURE_CommonDebug_SendStatsSendPacket;
            featureController->sendStatsStartSendingPacketFromDrone = ARCONTROLLER_FEATURE_CommonDebug_SendStatsStartSendingPacketFromDrone;
            featureController->sendStatsStopSendingPacketFromDrone = ARCONTROLLER_FEATURE_CommonDebug_SendStatsStopSendingPacketFromDrone;
            featureController->sendDebugSettingsGetAll = ARCONTROLLER_FEATURE_CommonDebug_SendDebugSettingsGetAll;
            featureController->sendDebugSettingsSet = ARCONTROLLER_FEATURE_CommonDebug_SendDebugSettingsSet;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_CommonDebug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_CommonDebug_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_CommonDebug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_CommonDebug_Delete (ARCONTROLLER_FEATURE_CommonDebug_t **feature)
{
    // -- Delete the commonDebug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_CommonDebug_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_CommonDebug_GetDictionary (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the commonDebug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_AddCallback (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>CommonDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_RemoveCallback (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>CommonDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_RegisterARCommands (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetCommonDebugStatsEventSendPacketCallback (&ARCONTROLLER_FEATURE_CommonDebug_StatsEventSendPacketCallback, feature);
        ARCOMMANDS_Decoder_SetCommonDebugDebugSettingsStateInfoCallback (&ARCONTROLLER_FEATURE_CommonDebug_DebugSettingsStateInfoCallback, feature);
        ARCOMMANDS_Decoder_SetCommonDebugDebugSettingsStateListChangedCallback (&ARCONTROLLER_FEATURE_CommonDebug_DebugSettingsStateListChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_UnregisterARCommands (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetCommonDebugStatsEventSendPacketCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonDebugDebugSettingsStateInfoCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonDebugDebugSettingsStateListChangedCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendStatsSendPacket (ARCONTROLLER_FEATURE_CommonDebug_t *feature, char * packet)
{
    // -- Send a command <code>StatsSendPacket</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SendPacket command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugStatsSendPacket(cmdBuffer, sizeof(cmdBuffer), &cmdSize, packet);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendStatsStartSendingPacketFromDrone (ARCONTROLLER_FEATURE_CommonDebug_t *feature, uint8_t frequency, uint8_t packetSize, uint32_t date)
{
    // -- Send a command <code>StatsStartSendingPacketFromDrone</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartSendingPacketFromDrone command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugStatsStartSendingPacketFromDrone(cmdBuffer, sizeof(cmdBuffer), &cmdSize, frequency, packetSize, date);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendStatsStopSendingPacketFromDrone (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Send a command <code>StatsStopSendingPacketFromDrone</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopSendingPacketFromDrone command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugStatsStopSendingPacketFromDrone(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendDebugSettingsGetAll (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Send a command <code>DebugSettingsGetAll</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAll command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugDebugSettingsGetAll(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendDebugSettingsSet (ARCONTROLLER_FEATURE_CommonDebug_t *feature, uint16_t id, char * value)
{
    // -- Send a command <code>DebugSettingsSet</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Set command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugDebugSettingsSet(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_CommonDebug_StatsEventSendPacketCallback (char * _packet, void *customData)
{
    // -- callback used when the command <code>StatsEventSendPacket</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_CommonDebug_t *feature = (ARCONTROLLER_FEATURE_CommonDebug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_STATSEVENT_SENDPACKET;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_CommonDebug_NewCmdElementStatsEventSendPacket (feature,  _packet, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_CommonDebug_DebugSettingsStateInfoCallback (uint8_t _listFlags, uint16_t _id, char * _label, eARCOMMANDS_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_TYPE _type, eARCOMMANDS_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_MODE _mode, char * _range_min, char * _range_max, char * _range_step, char * _value, void *customData)
{
    // -- callback used when the command <code>DebugSettingsStateInfo</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_CommonDebug_t *feature = (ARCONTROLLER_FEATURE_CommonDebug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_CommonDebug_NewCmdElementDebugSettingsStateInfo (feature,  _listFlags,  _id,  _label,  _type,  _mode,  _range_min,  _range_max,  _range_step,  _value, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_CommonDebug_DebugSettingsStateListChangedCallback (uint16_t _id, char * _value, void *customData)
{
    // -- callback used when the command <code>DebugSettingsStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_CommonDebug_t *feature = (ARCONTROLLER_FEATURE_CommonDebug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_LISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_CommonDebug_NewCmdElementDebugSettingsStateListChanged (feature,  _id,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_CommonDebug_NewCmdElementStatsEventSendPacket (ARCONTROLLER_FEATURE_CommonDebug_t *feature, char * _packet, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event StatsEventSendPacket -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_STATSEVENT_SENDPACKET_PACKET;
            strLength = strlen (_packet);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _packet, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_CommonDebug_NewCmdElementDebugSettingsStateInfo (ARCONTROLLER_FEATURE_CommonDebug_t *feature, uint8_t _listFlags, uint16_t _id, char * _label, eARCOMMANDS_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_TYPE _type, eARCOMMANDS_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_MODE _mode, char * _range_min, char * _range_max, char * _range_step, char * _value, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DebugSettingsStateInfo -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_LISTFLAGS;
            argDictNewElement->value.U8 = _listFlags;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_ID;
            argDictNewElement->value.U16 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_LABEL;
            strLength = strlen (_label);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _label, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_RANGE_MIN;
            strLength = strlen (_range_min);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _range_min, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_RANGE_MAX;
            strLength = strlen (_range_max);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _range_max, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_RANGE_STEP;
            strLength = strlen (_range_step);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _range_step, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_INFO_VALUE;
            strLength = strlen (_value);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _value, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_CommonDebug_NewCmdElementDebugSettingsStateListChanged (ARCONTROLLER_FEATURE_CommonDebug_t *feature, uint16_t _id, char * _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DebugSettingsStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_LISTCHANGED_ID;
            argDictNewElement->value.U16 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_DEBUGSETTINGSSTATE_LISTCHANGED_VALUE;
            strLength = strlen (_value);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _value, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SetNetworkController (ARCONTROLLER_FEATURE_CommonDebug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_CommonDebug_GetCommandElements (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE follow_me --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_AVAILABILITY_TYPE = "arcontroller_dictionary_key_follow_me_availability_type";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RUN_TYPE = "arcontroller_dictionary_key_follow_me_run_type";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_geographicconfigchanged_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_DISTANCE = "arcontroller_dictionary_key_follow_me_geographicconfigchanged_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_ELEVATION_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_geographicconfigchanged_elevation_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_ELEVATION = "arcontroller_dictionary_key_follow_me_geographicconfigchanged_elevation";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_AZIMUTH_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_geographicconfigchanged_azimuth_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_AZIMUTH = "arcontroller_dictionary_key_follow_me_geographicconfigchanged_azimuth";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_relativeconfigchanged_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_DISTANCE = "arcontroller_dictionary_key_follow_me_relativeconfigchanged_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_ELEVATION_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_relativeconfigchanged_elevation_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_ELEVATION = "arcontroller_dictionary_key_follow_me_relativeconfigchanged_elevation";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_AZIMUTH_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_relativeconfigchanged_azimuth_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_AZIMUTH = "arcontroller_dictionary_key_follow_me_relativeconfigchanged_azimuth";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_ANIMRUN_TYPE = "arcontroller_dictionary_key_follow_me_animrun_type";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_SPEED_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_spiralanimconfigchanged_speed_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_SPEED = "arcontroller_dictionary_key_follow_me_spiralanimconfigchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_REVOLUTION_NB_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_spiralanimconfigchanged_revolution_nb_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_REVOLUTION_NB = "arcontroller_dictionary_key_follow_me_spiralanimconfigchanged_revolution_nb";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_VERTICAL_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_spiralanimconfigchanged_vertical_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_VERTICAL_DISTANCE = "arcontroller_dictionary_key_follow_me_spiralanimconfigchanged_vertical_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_SPEED_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_swinganimconfigchanged_speed_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_SPEED = "arcontroller_dictionary_key_follow_me_swinganimconfigchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_VERTICAL_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_swinganimconfigchanged_vertical_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_VERTICAL_DISTANCE = "arcontroller_dictionary_key_follow_me_swinganimconfigchanged_vertical_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_SPEED_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_boomeranganimconfigchanged_speed_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_SPEED = "arcontroller_dictionary_key_follow_me_boomeranganimconfigchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_boomeranganimconfigchanged_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_DISTANCE = "arcontroller_dictionary_key_follow_me_boomeranganimconfigchanged_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_SPEED_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_candleanimconfigchanged_speed_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_SPEED = "arcontroller_dictionary_key_follow_me_candleanimconfigchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_VERTICAL_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_candleanimconfigchanged_vertical_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_VERTICAL_DISTANCE = "arcontroller_dictionary_key_follow_me_candleanimconfigchanged_vertical_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_SPEED_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_dollyslideanimconfigchanged_speed_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_SPEED = "arcontroller_dictionary_key_follow_me_dollyslideanimconfigchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_ANGLE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_dollyslideanimconfigchanged_angle_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_ANGLE = "arcontroller_dictionary_key_follow_me_dollyslideanimconfigchanged_angle";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_HORIZONTAL_DISTANCE_IS_DEFAULT = "arcontroller_dictionary_key_follow_me_dollyslideanimconfigchanged_horizontal_distance_is_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_HORIZONTAL_DISTANCE = "arcontroller_dictionary_key_follow_me_dollyslideanimconfigchanged_horizontal_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_USERFRAMINGPOSITIONCHANGED_HORIZONTAL = "arcontroller_dictionary_key_follow_me_userframingpositionchanged_horizontal";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_USERFRAMINGPOSITIONCHANGED_VERTICAL = "arcontroller_dictionary_key_follow_me_userframingpositionchanged_vertical";

ARCONTROLLER_FEATURE_FollowMe_t *ARCONTROLLER_FEATURE_FollowMe_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_FollowMe_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_FollowMe_t));
        if (featureController != NULL)
        {
            featureController->sendGeographicRun = ARCONTROLLER_FEATURE_FollowMe_SendGeographicRun;
            featureController->sendRelativeRun = ARCONTROLLER_FEATURE_FollowMe_SendRelativeRun;
            featureController->sendLookAtRun = ARCONTROLLER_FEATURE_FollowMe_SendLookAtRun;
            featureController->sendSpiralAnimRun = ARCONTROLLER_FEATURE_FollowMe_SendSpiralAnimRun;
            featureController->sendSwingAnimRun = ARCONTROLLER_FEATURE_FollowMe_SendSwingAnimRun;
            featureController->sendBoomerangAnimRun = ARCONTROLLER_FEATURE_FollowMe_SendBoomerangAnimRun;
            featureController->sendCandleAnimRun = ARCONTROLLER_FEATURE_FollowMe_SendCandleAnimRun;
            featureController->sendDollySlideAnimRun = ARCONTROLLER_FEATURE_FollowMe_SendDollySlideAnimRun;
            featureController->sendUserFramingPosition = ARCONTROLLER_FEATURE_FollowMe_SendUserFramingPosition;
            featureController->sendUserGPSData = ARCONTROLLER_FEATURE_FollowMe_SendUserGPSData;
            featureController->sendUserBaroData = ARCONTROLLER_FEATURE_FollowMe_SendUserBaroData;
            featureController->sendLynxDetection = ARCONTROLLER_FEATURE_FollowMe_SendLynxDetection;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_FollowMe_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_FollowMe_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_FollowMe_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_FollowMe_Delete (ARCONTROLLER_FEATURE_FollowMe_t **feature)
{
    // -- Delete the follow_me feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_FollowMe_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_FollowMe_GetDictionary (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the follow_me Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_AddCallback (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>FollowMe</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_RemoveCallback (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>FollowMe</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_RegisterARCommands (ARCONTROLLER_FEATURE_FollowMe_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetFollowMeAvailabilityCallback (&ARCONTROLLER_FEATURE_FollowMe_AvailabilityCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeRunCallback (&ARCONTROLLER_FEATURE_FollowMe_RunCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeGeographicConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_GeographicConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeRelativeConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_RelativeConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeAnimRunCallback (&ARCONTROLLER_FEATURE_FollowMe_AnimRunCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeSpiralAnimConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_SpiralAnimConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeSwingAnimConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_SwingAnimConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeBoomerangAnimConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_BoomerangAnimConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeCandleAnimConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_CandleAnimConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeDollySlideAnimConfigChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_DollySlideAnimConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeUserFramingPositionChangedCallback (&ARCONTROLLER_FEATURE_FollowMe_UserFramingPositionChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_UnregisterARCommands (ARCONTROLLER_FEATURE_FollowMe_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetFollowMeAvailabilityCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeRunCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeGeographicConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeRelativeConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeAnimRunCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeSpiralAnimConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeSwingAnimConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeBoomerangAnimConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeCandleAnimConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeDollySlideAnimConfigChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeUserFramingPositionChangedCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendGeographicRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t distance_is_default, float distance, uint8_t elevation_is_default, float elevation, uint8_t azimuth_is_default, float azimuth)
{
    // -- Send a command <code>GeographicRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GeographicRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeGeographicRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, distance_is_default, distance, elevation_is_default, elevation, azimuth_is_default, azimuth);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendRelativeRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t distance_is_default, float distance, uint8_t elevation_is_default, float elevation, uint8_t azimuth_is_default, float azimuth)
{
    // -- Send a command <code>RelativeRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RelativeRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeRelativeRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, distance_is_default, distance, elevation_is_default, elevation, azimuth_is_default, azimuth);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendLookAtRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start)
{
    // -- Send a command <code>LookAtRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send LookAtRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeLookAtRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendSpiralAnimRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t speed_is_default, float speed, uint8_t revolution_nb_is_default, float revolution_number, uint8_t vertical_distance_is_default, float vertical_distance)
{
    // -- Send a command <code>SpiralAnimRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SpiralAnimRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeSpiralAnimRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, speed_is_default, speed, revolution_nb_is_default, revolution_number, vertical_distance_is_default, vertical_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendSwingAnimRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t speed_is_default, float speed, uint8_t vertical_distance_is_default, float vertical_distance)
{
    // -- Send a command <code>SwingAnimRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SwingAnimRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeSwingAnimRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, speed_is_default, speed, vertical_distance_is_default, vertical_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendBoomerangAnimRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t speed_is_default, float speed, uint8_t distance_is_default, float distance)
{
    // -- Send a command <code>BoomerangAnimRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send BoomerangAnimRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeBoomerangAnimRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, speed_is_default, speed, distance_is_default, distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendCandleAnimRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t speed_is_default, float speed, uint8_t vertical_distance_is_default, float vertical_distance)
{
    // -- Send a command <code>CandleAnimRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CandleAnimRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeCandleAnimRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, speed_is_default, speed, vertical_distance_is_default, vertical_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendDollySlideAnimRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t start, uint8_t speed_is_default, float speed, uint8_t angle_is_default, float angle, uint8_t horizontal_distance_is_default, float horizontal_distance)
{
    // -- Send a command <code>DollySlideAnimRun</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DollySlideAnimRun command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeDollySlideAnimRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start, speed_is_default, speed, angle_is_default, angle, horizontal_distance_is_default, horizontal_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendUserFramingPosition (ARCONTROLLER_FEATURE_FollowMe_t *feature, int8_t horizontal, int8_t vertical)
{
    // -- Send a command <code>UserFramingPosition</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserFramingPosition command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeUserFramingPosition(cmdBuffer, sizeof(cmdBuffer), &cmdSize, horizontal, vertical);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendUserGPSData (ARCONTROLLER_FEATURE_FollowMe_t *feature, double latitude, double longitude, float altitude, float horizontal_accuracy, float vertical_accuracy, float north_speed, float east_speed, float down_speed, double timestamp)
{
    // -- Send a command <code>UserGPSData</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserGPSData command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeUserGPSData(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude, horizontal_accuracy, vertical_accuracy, north_speed, east_speed, down_speed, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendUserBaroData (ARCONTROLLER_FEATURE_FollowMe_t *feature, float pressure, double timestamp)
{
    // -- Send a command <code>UserBaroData</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserBaroData command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeUserBaroData(cmdBuffer, sizeof(cmdBuffer), &cmdSize, pressure, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendLynxDetection (ARCONTROLLER_FEATURE_FollowMe_t *feature, float target_pan, float target_tilt, float change_of_scale, uint8_t confidence_index, uint8_t is_new_selection, uint64_t timestamp)
{
    // -- Send a command <code>LynxDetection</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send LynxDetection command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeLynxDetection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, target_pan, target_tilt, change_of_scale, confidence_index, is_new_selection, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_FollowMe_AvailabilityCallback (eARCOMMANDS_FOLLOW_ME_TYPES_AVAILABLE _type, void *customData)
{
    // -- callback used when the command <code>Availability</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_AVAILABILITY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementAvailability (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_RunCallback (eARCOMMANDS_FOLLOW_ME_TYPE _type, void *customData)
{
    // -- callback used when the command <code>Run</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RUN;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementRun (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_GeographicConfigChangedCallback (uint8_t _distance_is_default, float _distance, uint8_t _elevation_is_default, float _elevation, uint8_t _azimuth_is_default, float _azimuth, void *customData)
{
    // -- callback used when the command <code>GeographicConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementGeographicConfigChanged (feature,  _distance_is_default,  _distance,  _elevation_is_default,  _elevation,  _azimuth_is_default,  _azimuth, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_RelativeConfigChangedCallback (uint8_t _distance_is_default, float _distance, uint8_t _elevation_is_default, float _elevation, uint8_t _azimuth_is_default, float _azimuth, void *customData)
{
    // -- callback used when the command <code>RelativeConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementRelativeConfigChanged (feature,  _distance_is_default,  _distance,  _elevation_is_default,  _elevation,  _azimuth_is_default,  _azimuth, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_AnimRunCallback (eARCOMMANDS_FOLLOW_ME_ANIM_TYPE _type, void *customData)
{
    // -- callback used when the command <code>AnimRun</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_ANIMRUN;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementAnimRun (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_SpiralAnimConfigChangedCallback (uint8_t _speed_is_default, float _speed, uint8_t _revolution_nb_is_default, float _revolution_nb, uint8_t _vertical_distance_is_default, float _vertical_distance, void *customData)
{
    // -- callback used when the command <code>SpiralAnimConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementSpiralAnimConfigChanged (feature,  _speed_is_default,  _speed,  _revolution_nb_is_default,  _revolution_nb,  _vertical_distance_is_default,  _vertical_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_SwingAnimConfigChangedCallback (uint8_t _speed_is_default, float _speed, uint8_t _vertical_distance_is_default, float _vertical_distance, void *customData)
{
    // -- callback used when the command <code>SwingAnimConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementSwingAnimConfigChanged (feature,  _speed_is_default,  _speed,  _vertical_distance_is_default,  _vertical_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_BoomerangAnimConfigChangedCallback (uint8_t _speed_is_default, float _speed, uint8_t _distance_is_default, float _distance, void *customData)
{
    // -- callback used when the command <code>BoomerangAnimConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementBoomerangAnimConfigChanged (feature,  _speed_is_default,  _speed,  _distance_is_default,  _distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_CandleAnimConfigChangedCallback (uint8_t _speed_is_default, float _speed, uint8_t _vertical_distance_is_default, float _vertical_distance, void *customData)
{
    // -- callback used when the command <code>CandleAnimConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementCandleAnimConfigChanged (feature,  _speed_is_default,  _speed,  _vertical_distance_is_default,  _vertical_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_DollySlideAnimConfigChangedCallback (uint8_t _speed_is_default, float _speed, uint8_t _angle_is_default, float _angle, uint8_t _horizontal_distance_is_default, float _horizontal_distance, void *customData)
{
    // -- callback used when the command <code>DollySlideAnimConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementDollySlideAnimConfigChanged (feature,  _speed_is_default,  _speed,  _angle_is_default,  _angle,  _horizontal_distance_is_default,  _horizontal_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_UserFramingPositionChangedCallback (int8_t _horizontal, int8_t _vertical, void *customData)
{
    // -- callback used when the command <code>UserFramingPositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_USERFRAMINGPOSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementUserFramingPositionChanged (feature,  _horizontal,  _vertical, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementAvailability (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_TYPES_AVAILABLE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event Availability -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_AVAILABILITY_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event Run -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RUN_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementGeographicConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _distance_is_default, float _distance, uint8_t _elevation_is_default, float _elevation, uint8_t _azimuth_is_default, float _azimuth, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GeographicConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_ELEVATION_IS_DEFAULT;
            argDictNewElement->value.U8 = _elevation_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_ELEVATION;
            argDictNewElement->value.Float = _elevation;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_AZIMUTH_IS_DEFAULT;
            argDictNewElement->value.U8 = _azimuth_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIGCHANGED_AZIMUTH;
            argDictNewElement->value.Float = _azimuth;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementRelativeConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _distance_is_default, float _distance, uint8_t _elevation_is_default, float _elevation, uint8_t _azimuth_is_default, float _azimuth, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RelativeConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_ELEVATION_IS_DEFAULT;
            argDictNewElement->value.U8 = _elevation_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_ELEVATION;
            argDictNewElement->value.Float = _elevation;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_AZIMUTH_IS_DEFAULT;
            argDictNewElement->value.U8 = _azimuth_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIGCHANGED_AZIMUTH;
            argDictNewElement->value.Float = _azimuth;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementAnimRun (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_ANIM_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimRun -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_ANIMRUN_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementSpiralAnimConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _speed_is_default, float _speed, uint8_t _revolution_nb_is_default, float _revolution_nb, uint8_t _vertical_distance_is_default, float _vertical_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpiralAnimConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_SPEED_IS_DEFAULT;
            argDictNewElement->value.U8 = _speed_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_REVOLUTION_NB_IS_DEFAULT;
            argDictNewElement->value.U8 = _revolution_nb_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_REVOLUTION_NB;
            argDictNewElement->value.Float = _revolution_nb;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_VERTICAL_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _vertical_distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SPIRALANIMCONFIGCHANGED_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementSwingAnimConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _speed_is_default, float _speed, uint8_t _vertical_distance_is_default, float _vertical_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SwingAnimConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_SPEED_IS_DEFAULT;
            argDictNewElement->value.U8 = _speed_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_VERTICAL_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _vertical_distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIGCHANGED_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementBoomerangAnimConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _speed_is_default, float _speed, uint8_t _distance_is_default, float _distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event BoomerangAnimConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_SPEED_IS_DEFAULT;
            argDictNewElement->value.U8 = _speed_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIGCHANGED_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementCandleAnimConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _speed_is_default, float _speed, uint8_t _vertical_distance_is_default, float _vertical_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CandleAnimConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_SPEED_IS_DEFAULT;
            argDictNewElement->value.U8 = _speed_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_VERTICAL_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _vertical_distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIGCHANGED_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementDollySlideAnimConfigChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _speed_is_default, float _speed, uint8_t _angle_is_default, float _angle, uint8_t _horizontal_distance_is_default, float _horizontal_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DollySlideAnimConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_SPEED_IS_DEFAULT;
            argDictNewElement->value.U8 = _speed_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_ANGLE_IS_DEFAULT;
            argDictNewElement->value.U8 = _angle_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_ANGLE;
            argDictNewElement->value.Float = _angle;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_HORIZONTAL_DISTANCE_IS_DEFAULT;
            argDictNewElement->value.U8 = _horizontal_distance_is_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIGCHANGED_HORIZONTAL_DISTANCE;
            argDictNewElement->value.Float = _horizontal_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementUserFramingPositionChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, int8_t _horizontal, int8_t _vertical, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UserFramingPositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_USERFRAMINGPOSITIONCHANGED_HORIZONTAL;
            argDictNewElement->value.I8 = _horizontal;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_USERFRAMINGPOSITIONCHANGED_VERTICAL;
            argDictNewElement->value.I8 = _vertical;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SetNetworkController (ARCONTROLLER_FEATURE_FollowMe_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_GetCommandElements (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE JumpingSumo --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_posturechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_SPEED = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_speedchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_REALSPEED = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_speedchanged_realspeed";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_flyingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumploadchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumptypechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumpmotorproblemchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_jumpingsumo_settingsstate_productgpsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_jumpingsumo_settingsstate_productgpsversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_videoeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY = "arcontroller_dictionary_key_jumpingsumo_networkstate_linkqualitychanged_quality";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED_VOLUME = "arcontroller_dictionary_key_jumpingsumo_audiosettingsstate_mastervolumechanged_volume";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME = "arcontroller_dictionary_key_jumpingsumo_audiosettingsstate_themechanged_theme";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_UUID = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_uuid";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_VERSION = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_version";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_PRODUCT = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_product";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_NAME = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_name";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_LASTMODIFIED = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_lastmodified";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptuploadchanged_resultcode";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptdeletechanged_resultcode";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_playscriptchanged_resultcode";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR = "arcontroller_dictionary_key_jumpingsumo_speedsettingsstate_outdoorchanged_outdoor";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_jumpingsumo_mediastreamingstate_videoenablechanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_jumpingsumo_videosettingsstate_autorecordchanged_enabled";

ARCONTROLLER_FEATURE_JumpingSumo_t *ARCONTROLLER_FEATURE_JumpingSumo_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_JumpingSumo_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumo_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDSpeed = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDSpeed;
            featureController->setPilotingPCMDTurn = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDTurn;
            featureController->sendPilotingPosture = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPosture;
            featureController->sendPilotingAddCapOffset = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingAddCapOffset;
            featureController->sendPilotingUserTakeOff = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingUserTakeOff;
            featureController->sendPilotingLand = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingLand;
            featureController->sendAnimationsJumpStop = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpStop;
            featureController->sendAnimationsJumpCancel = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpCancel;
            featureController->sendAnimationsJumpLoad = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpLoad;
            featureController->sendAnimationsJump = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJump;
            featureController->sendAnimationsSimpleAnimation = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsSimpleAnimation;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPicture;
            featureController->sendMediaRecordVideo = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideo;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideoV2;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkSettingsWifiSelection;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiAuthChannel;
            featureController->sendAudioSettingsMasterVolume = ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsMasterVolume;
            featureController->sendAudioSettingsTheme = ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsTheme;
            featureController->sendRoadPlanAllScriptsMetadata = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanAllScriptsMetadata;
            featureController->sendRoadPlanScriptUploaded = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptUploaded;
            featureController->sendRoadPlanScriptDelete = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptDelete;
            featureController->sendRoadPlanPlayScript = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanPlayScript;
            featureController->sendSpeedSettingsOutdoor = ARCONTROLLER_FEATURE_JumpingSumo_SendSpeedSettingsOutdoor;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaStreamingVideoEnable;
            featureController->sendVideoSettingsAutorecord = ARCONTROLLER_FEATURE_JumpingSumo_SendVideoSettingsAutorecord;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumo_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_JumpingSumo_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_JumpingSumo_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_JumpingSumo_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_JumpingSumo_Delete (ARCONTROLLER_FEATURE_JumpingSumo_t **feature)
{
    // -- Delete the JumpingSumo feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_JumpingSumo_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_JumpingSumo_GetDictionary (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the JumpingSumo Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_AddCallback (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>JumpingSumo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_RemoveCallback (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>JumpingSumo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_RegisterARCommands (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_PilotingStatePostureChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateSpeedChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateFlyingStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpLoadChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpTypeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpMotorProblemChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_SettingsStateProductGPSVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Callback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Callback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventVideoEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateLinkQualityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateMasterVolumeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateThemeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptMetadataListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateAllScriptsMetadataChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptUploadChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptDeleteChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStatePlayScriptChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_SpeedSettingsStateOutdoorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaStreamingStateVideoEnableChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsStateAutorecordChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_VideoSettingsStateAutorecordChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_UnregisterARCommands (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateFlyingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsStateAutorecordChangedCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPCMD (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t flag, int8_t speed, int8_t turn)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, speed, turn);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMD (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _flag, int8_t _speed, int8_t _turn)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->speed = _speed;
        feature->privatePart->PilotingPCMDParameters->turn = _turn;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_JumpingSumo_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->speed, feature->privatePart->PilotingPCMDParameters->turn);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDSpeed (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _speed)
{
    // -- Set the speed for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->speed = _speed;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDTurn (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _turn)
{
    // -- Set the turn for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->turn = _turn;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPosture (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE type)
{
    // -- Send a command <code>PilotingPosture</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Posture command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPosture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingAddCapOffset (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, float offset)
{
    // -- Send a command <code>PilotingAddCapOffset</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AddCapOffset command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingAddCapOffset(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingUserTakeOff (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingUserTakeOff</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserTakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingUserTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingLand (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>PilotingLand</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Land command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingLand(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpStop (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AnimationsJumpStop</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpStop command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpCancel (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AnimationsJumpCancel</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpCancel command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpCancel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpLoad (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AnimationsJumpLoad</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpLoad command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpLoad(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJump (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE type)
{
    // -- Send a command <code>AnimationsJump</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Jump command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJump(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsSimpleAnimation (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID id)
{
    // -- Send a command <code>AnimationsSimpleAnimation</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SimpleAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsSimpleAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPicture (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordPicture</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideo (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD record, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordVideo</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>MediaRecordVideoV2</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>NetworkSettingsWifiSelection</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiScan (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>NetworkWifiScan</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>NetworkWifiAuthChannel</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsMasterVolume (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t volume)
{
    // -- Send a command <code>AudioSettingsMasterVolume</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MasterVolume command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAudioSettingsMasterVolume(cmdBuffer, sizeof(cmdBuffer), &cmdSize, volume);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsTheme (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME theme)
{
    // -- Send a command <code>AudioSettingsTheme</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Theme command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAudioSettingsTheme(cmdBuffer, sizeof(cmdBuffer), &cmdSize, theme);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanAllScriptsMetadata (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>RoadPlanAllScriptsMetadata</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllScriptsMetadata command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanAllScriptsMetadata(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptUploaded (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid, char * md5Hash)
{
    // -- Send a command <code>RoadPlanScriptUploaded</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ScriptUploaded command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanScriptUploaded(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid, md5Hash);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptDelete (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid)
{
    // -- Send a command <code>RoadPlanScriptDelete</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ScriptDelete command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanScriptDelete(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanPlayScript (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid)
{
    // -- Send a command <code>RoadPlanPlayScript</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PlayScript command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanPlayScript(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendSpeedSettingsOutdoor (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>SpeedSettingsOutdoor</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Outdoor command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoSpeedSettingsOutdoor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t enable)
{
    // -- Send a command <code>MediaStreamingVideoEnable</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendVideoSettingsAutorecord (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t enabled)
{
    // -- Send a command <code>VideoSettingsAutorecord</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Autorecord command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoVideoSettingsAutorecord(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStatePostureChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStatePostureChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStatePostureChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateAlertStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateSpeedChangedCallback (int8_t _speed, int16_t _realSpeed, void *customData)
{
    // -- callback used when the command <code>PilotingStateSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateSpeedChanged (feature,  _speed,  _realSpeed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_FLYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateFlyingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpLoadChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AnimationsStateJumpLoadChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpLoadChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpTypeChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AnimationsStateJumpTypeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpTypeChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpMotorProblemChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>AnimationsStateJumpMotorProblemChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpMotorProblemChanged (feature,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_SettingsStateProductGPSVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductGPSVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementSettingsStateProductGPSVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventVideoEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventVideoEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiScanListChangedCallback (char * _ssid, int16_t _rssi, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiScanListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiScanListChanged (feature,  _ssid,  _rssi,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiScanChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_ALLWIFISCANCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiScanChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateLinkQualityChangedCallback (uint8_t _quality, void *customData)
{
    // -- callback used when the command <code>NetworkStateLinkQualityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateLinkQualityChanged (feature,  _quality, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateMasterVolumeChangedCallback (uint8_t _volume, void *customData)
{
    // -- callback used when the command <code>AudioSettingsStateMasterVolumeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateMasterVolumeChanged (feature,  _volume, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateThemeChangedCallback (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme, void *customData)
{
    // -- callback used when the command <code>AudioSettingsStateThemeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateThemeChanged (feature,  _theme, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptMetadataListChangedCallback (char * _uuid, uint8_t _version, char * _product, char * _name, uint64_t _lastModified, void *customData)
{
    // -- callback used when the command <code>RoadPlanStateScriptMetadataListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptMetadataListChanged (feature,  _uuid,  _version,  _product,  _name,  _lastModified, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateAllScriptsMetadataChangedCallback (void *customData)
{
    // -- callback used when the command <code>RoadPlanStateAllScriptsMetadataChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_ALLSCRIPTSMETADATACHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateAllScriptsMetadataChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptUploadChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>RoadPlanStateScriptUploadChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptUploadChanged (feature,  _resultCode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptDeleteChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>RoadPlanStateScriptDeleteChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptDeleteChanged (feature,  _resultCode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStatePlayScriptChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>RoadPlanStatePlayScriptChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStatePlayScriptChanged (feature,  _resultCode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_SpeedSettingsStateOutdoorChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateOutdoorChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementSpeedSettingsStateOutdoorChanged (feature,  _outdoor, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>MediaStreamingStateVideoEnableChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaStreamingStateVideoEnableChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_VideoSettingsStateAutorecordChangedCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateAutorecordChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_VIDEOSETTINGSSTATE_AUTORECORDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementVideoSettingsStateAutorecordChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStatePostureChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePostureChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateSpeedChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _speed, int16_t _realSpeed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_SPEED;
            argDictNewElement->value.I8 = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_REALSPEED;
            argDictNewElement->value.I16 = _realSpeed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateFlyingStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpLoadChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateJumpLoadChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpTypeChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateJumpTypeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpMotorProblemChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateJumpMotorProblemChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementSettingsStateProductGPSVersionChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * _software, char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductGPSVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChangedV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventVideoEventChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventVideoEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiScanListChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * _ssid, int16_t _rssi, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiScanListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiScanChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiScanChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateLinkQualityChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _quality, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateLinkQualityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY;
            argDictNewElement->value.U8 = _quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateMasterVolumeChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _volume, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AudioSettingsStateMasterVolumeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED_VOLUME;
            argDictNewElement->value.U8 = _volume;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateThemeChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AudioSettingsStateThemeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME;
            argDictNewElement->value.I32 = _theme;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptMetadataListChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * _uuid, uint8_t _version, char * _product, char * _name, uint64_t _lastModified, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateScriptMetadataListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_uuid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _uuid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_UUID;
            strLength = strlen (_uuid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _uuid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_VERSION;
            argDictNewElement->value.U8 = _version;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_PRODUCT;
            strLength = strlen (_product);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _product, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_LASTMODIFIED;
            argDictNewElement->value.U64 = _lastModified;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateAllScriptsMetadataChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateAllScriptsMetadataChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptUploadChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateScriptUploadChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptDeleteChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateScriptDeleteChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStatePlayScriptChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStatePlayScriptChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementSpeedSettingsStateOutdoorChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _outdoor, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateOutdoorChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaStreamingStateVideoEnableChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaStreamingStateVideoEnableChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementVideoSettingsStateAutorecordChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateAutorecordChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetNetworkController (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_GetCommandElements (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE MiniDrone --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_flyingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_autotakeoffmodechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE = "arcontroller_dictionary_key_minidrone_pilotingstate_flyingmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_minidrone_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_minidrone_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED_PRESENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_wheelschanged_present";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxhorizontalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxhorizontalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxhorizontalspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_MOTOR = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_motor";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_TYPE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productinertialversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productinertialversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED_ENABLE = "arcontroller_dictionary_key_minidrone_settingsstate_cutoutmodechanged_enable";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED_DELAY = "arcontroller_dictionary_key_minidrone_floodcontrolstate_floodcontrolchanged_delay";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_ID = "arcontroller_dictionary_key_minidrone_usbaccessorystate_lightstate_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE = "arcontroller_dictionary_key_minidrone_usbaccessorystate_lightstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_INTENSITY = "arcontroller_dictionary_key_minidrone_usbaccessorystate_lightstate_intensity";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_ID = "arcontroller_dictionary_key_minidrone_usbaccessorystate_clawstate_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE = "arcontroller_dictionary_key_minidrone_usbaccessorystate_clawstate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_ID = "arcontroller_dictionary_key_minidrone_usbaccessorystate_gunstate_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE = "arcontroller_dictionary_key_minidrone_usbaccessorystate_gunstate_state";

ARCONTROLLER_FEATURE_MiniDrone_t *ARCONTROLLER_FEATURE_MiniDrone_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_MiniDrone_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDrone_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingFlatTrim = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlatTrim;
            featureController->sendPilotingTakeOff = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTakeOff;
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDRoll;
            featureController->setPilotingPCMDPitch = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPitch;
            featureController->setPilotingPCMDYaw = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDYaw;
            featureController->setPilotingPCMDGaz = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDGaz;
            featureController->setPilotingPCMDTimestamp = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDTimestamp;
            featureController->sendPilotingLanding = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingLanding;
            featureController->sendPilotingEmergency = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingEmergency;
            featureController->sendPilotingAutoTakeOffMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingAutoTakeOffMode;
            featureController->sendPilotingFlyingMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlyingMode;
            featureController->sendAnimationsFlip = ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsFlip;
            featureController->sendAnimationsCap = ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsCap;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPicture;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPictureV2;
            featureController->sendPilotingSettingsMaxAltitude = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxAltitude;
            featureController->sendPilotingSettingsMaxTilt = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxTilt;
            featureController->sendSpeedSettingsMaxVerticalSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxVerticalSpeed;
            featureController->sendSpeedSettingsMaxRotationSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxRotationSpeed;
            featureController->sendSpeedSettingsWheels = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsWheels;
            featureController->sendSpeedSettingsMaxHorizontalSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxHorizontalSpeed;
            featureController->sendSettingsCutOutMode = ARCONTROLLER_FEATURE_MiniDrone_SendSettingsCutOutMode;
            featureController->sendGPSControllerLatitudeForRun = ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLatitudeForRun;
            featureController->sendGPSControllerLongitudeForRun = ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLongitudeForRun;
            featureController->sendConfigurationControllerType = ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerType;
            featureController->sendConfigurationControllerName = ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerName;
            featureController->sendUsbAccessoryLightControl = ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryLightControl;
            featureController->sendUsbAccessoryClawControl = ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryClawControl;
            featureController->sendUsbAccessoryGunControl = ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryGunControl;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDrone_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_MiniDrone_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_MiniDrone_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_MiniDrone_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_MiniDrone_Delete (ARCONTROLLER_FEATURE_MiniDrone_t **feature)
{
    // -- Delete the MiniDrone feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_MiniDrone_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_MiniDrone_GetDictionary (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the MiniDrone Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_AddCallback (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>MiniDrone</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_RemoveCallback (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>MiniDrone</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_RegisterARCommands (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlatTrimChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAutoTakeOffModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingModeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Callback (&ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxTiltChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxVerticalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateWheelsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxHorizontalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductMotorsVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductInertialVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SettingsStateCutOutModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_FloodControlStateFloodControlChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateLightStateCallback (&ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateLightStateCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCallback (&ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateClawStateCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCallback (&ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateGunStateCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_UnregisterARCommands (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateLightStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlatTrim (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingFlatTrim</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlatTrim command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingFlatTrim(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTakeOff (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingTakeOff</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPCMD (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t flag, int8_t roll, int8_t pitch, int8_t yaw, int8_t gaz, uint32_t timestamp)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, roll, pitch, yaw, gaz, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMD (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _flag, int8_t _roll, int8_t _pitch, int8_t _yaw, int8_t _gaz, uint32_t _timestamp)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->roll = _roll;
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;
        feature->privatePart->PilotingPCMDParameters->timestamp = _timestamp;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_MiniDrone_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_MiniDrone_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>MiniDrone</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->roll, feature->privatePart->PilotingPCMDParameters->pitch, feature->privatePart->PilotingPCMDParameters->yaw, feature->privatePart->PilotingPCMDParameters->gaz, feature->privatePart->PilotingPCMDParameters->timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->roll = _roll;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPitch (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _pitch)
{
    // -- Set the pitch for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDYaw (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _yaw)
{
    // -- Set the yaw for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDGaz (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _gaz)
{
    // -- Set the gaz for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDTimestamp (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint32_t _timestamp)
{
    // -- Set the timestamp for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->timestamp = _timestamp;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingLanding (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingLanding</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Landing command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingLanding(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingEmergency (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingEmergency</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Emergency command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingEmergency(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingAutoTakeOffMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingAutoTakeOffMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoTakeOffMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingAutoTakeOffMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlyingMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE mode)
{
    // -- Send a command <code>PilotingFlyingMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlyingMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingFlyingMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsFlip (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION direction)
{
    // -- Send a command <code>AnimationsFlip</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Flip command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneAnimationsFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsCap (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int16_t offset)
{
    // -- Send a command <code>AnimationsCap</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Cap command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneAnimationsCap(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPicture (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordPicture</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxAltitude (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxAltitude</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxTilt (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxTilt</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxTilt command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxTilt(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxVerticalSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxVerticalSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxRotationSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxRotationSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsWheels (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t present)
{
    // -- Send a command <code>SpeedSettingsWheels</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Wheels command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsWheels(cmdBuffer, sizeof(cmdBuffer), &cmdSize, present);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxHorizontalSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxHorizontalSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxHorizontalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxHorizontalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSettingsCutOutMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t enable)
{
    // -- Send a command <code>SettingsCutOutMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CutOutMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSettingsCutOutMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLatitudeForRun (ARCONTROLLER_FEATURE_MiniDrone_t *feature, double latitude)
{
    // -- Send a command <code>GPSControllerLatitudeForRun</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerLatitudeForRun command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneGPSControllerLatitudeForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLongitudeForRun (ARCONTROLLER_FEATURE_MiniDrone_t *feature, double longitude)
{
    // -- Send a command <code>GPSControllerLongitudeForRun</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerLongitudeForRun command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneGPSControllerLongitudeForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, longitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerType (ARCONTROLLER_FEATURE_MiniDrone_t *feature, char * type)
{
    // -- Send a command <code>ConfigurationControllerType</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerType command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneConfigurationControllerType(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerName (ARCONTROLLER_FEATURE_MiniDrone_t *feature, char * name)
{
    // -- Send a command <code>ConfigurationControllerName</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerName command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneConfigurationControllerName(cmdBuffer, sizeof(cmdBuffer), &cmdSize, name);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryLightControl (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t id, eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE mode, uint8_t intensity)
{
    // -- Send a command <code>UsbAccessoryLightControl</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send LightControl command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryLightControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, mode, intensity);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryClawControl (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t id, eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION action)
{
    // -- Send a command <code>UsbAccessoryClawControl</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ClawControl command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryClawControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, action);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryGunControl (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t id, eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION action)
{
    // -- Send a command <code>UsbAccessoryGunControl</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GunControl command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryGunControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, action);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlatTrimChangedCallback (void *customData)
{
    // -- callback used when the command <code>PilotingStateFlatTrimChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLATTRIMCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlatTrimChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAlertStateChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAutoTakeOffModeChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAutoTakeOffModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAutoTakeOffModeChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingModeChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxTiltChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxTiltChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxTiltChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxVerticalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxVerticalSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateWheelsChangedCallback (uint8_t _present, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateWheelsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateWheelsChanged (feature,  _present, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxHorizontalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxHorizontalSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxHorizontalSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductMotorsVersionChangedCallback (uint8_t _motor, char * _type, char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductMotorsVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductMotorsVersionChanged (feature,  _motor,  _type,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductInertialVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductInertialVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductInertialVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateCutOutModeChangedCallback (uint8_t _enable, void *customData)
{
    // -- callback used when the command <code>SettingsStateCutOutModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateCutOutModeChanged (feature,  _enable, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_FloodControlStateFloodControlChangedCallback (uint16_t _delay, void *customData)
{
    // -- callback used when the command <code>FloodControlStateFloodControlChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementFloodControlStateFloodControlChanged (feature,  _delay, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateLightStateCallback (uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE _state, uint8_t _intensity, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>UsbAccessoryStateLightState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateLightState (feature,  _id,  _state,  _intensity,  _list_flags, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateClawStateCallback (uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE _state, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>UsbAccessoryStateClawState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateClawState (feature,  _id,  _state,  _list_flags, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateGunStateCallback (uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE _state, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>UsbAccessoryStateGunState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateGunState (feature,  _id,  _state,  _list_flags, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlatTrimChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlatTrimChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAutoTakeOffModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAutoTakeOffModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxTiltChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxTiltChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxVerticalSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateWheelsChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _present, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateWheelsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED_PRESENT;
            argDictNewElement->value.U8 = _present;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxHorizontalSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxHorizontalSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductMotorsVersionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _motor, char * _type, char * _software, char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductMotorsVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_MOTOR;
            argDictNewElement->value.U8 = _motor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_TYPE;
            strLength = strlen (_type);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _type, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductInertialVersionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, char * _software, char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductInertialVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateCutOutModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _enable, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateCutOutModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED_ENABLE;
            argDictNewElement->value.U8 = _enable;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementFloodControlStateFloodControlChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint16_t _delay, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FloodControlStateFloodControlChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED_DELAY;
            argDictNewElement->value.U16 = _delay;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateLightState (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE _state, uint8_t _intensity, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UsbAccessoryStateLightState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_INTENSITY;
            argDictNewElement->value.U8 = _intensity;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateClawState (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE _state, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UsbAccessoryStateClawState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateGunState (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE _state, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UsbAccessoryStateGunState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetNetworkController (ARCONTROLLER_FEATURE_MiniDrone_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_GetCommandElements (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE pro --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS = "arcontroller_dictionary_key_pro_prostate_supportedfeatures_status";
const char *ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_SUPPORTEDFEATURES_FEATURES = "arcontroller_dictionary_key_pro_prostate_supportedfeatures_features";

const char *ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_FEATURESACTIVATED_FEATURES = "arcontroller_dictionary_key_pro_prostate_featuresactivated_features";

const char *ARCONTROLLER_DICTIONARY_KEY_PRO_PROEVENT_CHALLENGEEVENT_CHALLENGE = "arcontroller_dictionary_key_pro_proevent_challengeevent_challenge";

ARCONTROLLER_FEATURE_Pro_t *ARCONTROLLER_FEATURE_Pro_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Pro_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Pro_t));
        if (featureController != NULL)
        {
            featureController->sendProBoughtFeatures = ARCONTROLLER_FEATURE_Pro_SendProBoughtFeatures;
            featureController->sendProResponse = ARCONTROLLER_FEATURE_Pro_SendProResponse;
            featureController->sendProActivateFeatures = ARCONTROLLER_FEATURE_Pro_SendProActivateFeatures;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Pro_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_Pro_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Pro_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Pro_Delete (ARCONTROLLER_FEATURE_Pro_t **feature)
{
    // -- Delete the pro feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_Pro_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Pro_GetDictionary (ARCONTROLLER_FEATURE_Pro_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the pro Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_AddCallback (ARCONTROLLER_FEATURE_Pro_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Pro</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_RemoveCallback (ARCONTROLLER_FEATURE_Pro_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Pro</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_RegisterARCommands (ARCONTROLLER_FEATURE_Pro_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetProProStateSupportedFeaturesCallback (&ARCONTROLLER_FEATURE_Pro_ProStateSupportedFeaturesCallback, feature);
        ARCOMMANDS_Decoder_SetProProStateFeaturesActivatedCallback (&ARCONTROLLER_FEATURE_Pro_ProStateFeaturesActivatedCallback, feature);
        ARCOMMANDS_Decoder_SetProProEventChallengeEventCallback (&ARCONTROLLER_FEATURE_Pro_ProEventChallengeEventCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_UnregisterARCommands (ARCONTROLLER_FEATURE_Pro_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetProProStateSupportedFeaturesCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetProProStateFeaturesActivatedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetProProEventChallengeEventCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_SendProBoughtFeatures (ARCONTROLLER_FEATURE_Pro_t *feature, uint64_t features)
{
    // -- Send a command <code>ProBoughtFeatures</code> in project <code>Pro</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send BoughtFeatures command
        cmdError = ARCOMMANDS_Generator_GenerateProProBoughtFeatures(cmdBuffer, sizeof(cmdBuffer), &cmdSize, features);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_SendProResponse (ARCONTROLLER_FEATURE_Pro_t *feature, uint8_t listFlags, char * signedChallenge)
{
    // -- Send a command <code>ProResponse</code> in project <code>Pro</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Response command
        cmdError = ARCOMMANDS_Generator_GenerateProProResponse(cmdBuffer, sizeof(cmdBuffer), &cmdSize, listFlags, signedChallenge);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_SendProActivateFeatures (ARCONTROLLER_FEATURE_Pro_t *feature, uint64_t features)
{
    // -- Send a command <code>ProActivateFeatures</code> in project <code>Pro</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ActivateFeatures command
        cmdError = ARCOMMANDS_Generator_GenerateProProActivateFeatures(cmdBuffer, sizeof(cmdBuffer), &cmdSize, features);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Pro_ProStateSupportedFeaturesCallback (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS _status, uint64_t _features, void *customData)
{
    // -- callback used when the command <code>ProStateSupportedFeatures</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Pro_t *feature = (ARCONTROLLER_FEATURE_Pro_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_SUPPORTEDFEATURES;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Pro_NewCmdElementProStateSupportedFeatures (feature,  _status,  _features, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Pro_ProStateFeaturesActivatedCallback (uint64_t _features, void *customData)
{
    // -- callback used when the command <code>ProStateFeaturesActivated</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Pro_t *feature = (ARCONTROLLER_FEATURE_Pro_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_FEATURESACTIVATED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Pro_NewCmdElementProStateFeaturesActivated (feature,  _features, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Pro_ProEventChallengeEventCallback (char * _challenge, void *customData)
{
    // -- callback used when the command <code>ProEventChallengeEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Pro_t *feature = (ARCONTROLLER_FEATURE_Pro_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_PRO_PROEVENT_CHALLENGEEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Pro_NewCmdElementProEventChallengeEvent (feature,  _challenge, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Pro_NewCmdElementProStateSupportedFeatures (ARCONTROLLER_FEATURE_Pro_t *feature, eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS _status, uint64_t _features, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ProStateSupportedFeatures -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_SUPPORTEDFEATURES_FEATURES;
            argDictNewElement->value.U64 = _features;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Pro_NewCmdElementProStateFeaturesActivated (ARCONTROLLER_FEATURE_Pro_t *feature, uint64_t _features, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ProStateFeaturesActivated -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_PRO_PROSTATE_FEATURESACTIVATED_FEATURES;
            argDictNewElement->value.U64 = _features;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Pro_NewCmdElementProEventChallengeEvent (ARCONTROLLER_FEATURE_Pro_t *feature, char * _challenge, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ProEventChallengeEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_PRO_PROEVENT_CHALLENGEEVENT_CHALLENGE;
            strLength = strlen (_challenge);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _challenge, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Pro_SetNetworkController (ARCONTROLLER_FEATURE_Pro_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Pro_GetCommandElements (ARCONTROLLER_FEATURE_Pro_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE SkyController --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_BSSID = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_bssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SSID = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SECURED = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_secured";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SAVED = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_saved";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_RSSI = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_FREQUENCY = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_frequency";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_SSID = "arcontroller_dictionary_key_skycontroller_wifistate_connexionchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS = "arcontroller_dictionary_key_skycontroller_wifistate_connexionchanged_status";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED_LEVEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifisignalchanged_level";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST_NAME = "arcontroller_dictionary_key_skycontroller_devicestate_devicelist_name";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICENAME = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_devicename";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICEPRODUCTID = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_deviceproductid";



const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED_SERIALNUMBER = "arcontroller_dictionary_key_skycontroller_settingsstate_productserialchanged_serialnumber";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT = "arcontroller_dictionary_key_skycontroller_settingsstate_productvariantchanged_variant";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED_PERCENT = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_batterychanged_percent";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED_FIXED = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpsfixchanged_fixed";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LATITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_HEADING = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_heading";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED_SSID = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_accesspointssidchanged_ssid";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_accesspointchannelchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_ID = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_NAME = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_KEY_ID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_currentbuttonmappings_key_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_currentbuttonmappings_mapping_uid";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_availablebuttonmappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_NAME = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_availablebuttonmappings_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_AXIS_ID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_currentaxismappings_axis_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_currentaxismappings_mapping_uid";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_availableaxismappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_NAME = "arcontroller_dictionary_key_skycontroller_axismappingsstate_availableaxismappings_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_AXIS_ID = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_currentaxisfilters_axis_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_FILTER_UID_OR_BUILDER = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_currentaxisfilters_filter_uid_or_builder";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_FILTER_UID = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_presetaxisfilters_filter_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_NAME = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_presetaxisfilters_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE = "arcontroller_dictionary_key_skycontroller_copilotingstate_pilotingsource_source";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_X_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_x_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Y_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_y_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Z_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_z_quality";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE_ENABLED = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationqualityupdatesstate_enabled";


ARCONTROLLER_FEATURE_SkyController_t *ARCONTROLLER_FEATURE_SkyController_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_SkyController_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_SkyController_t));
        if (featureController != NULL)
        {
            featureController->sendWifiRequestWifiList = ARCONTROLLER_FEATURE_SkyController_SendWifiRequestWifiList;
            featureController->sendWifiRequestCurrentWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiRequestCurrentWifi;
            featureController->sendWifiConnectToWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiConnectToWifi;
            featureController->sendWifiForgetWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiForgetWifi;
            featureController->sendWifiWifiAuthChannel = ARCONTROLLER_FEATURE_SkyController_SendWifiWifiAuthChannel;
            featureController->sendDeviceRequestDeviceList = ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestDeviceList;
            featureController->sendDeviceRequestCurrentDevice = ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestCurrentDevice;
            featureController->sendDeviceConnectToDevice = ARCONTROLLER_FEATURE_SkyController_SendDeviceConnectToDevice;
            featureController->sendSettingsAllSettings = ARCONTROLLER_FEATURE_SkyController_SendSettingsAllSettings;
            featureController->sendSettingsReset = ARCONTROLLER_FEATURE_SkyController_SendSettingsReset;
            featureController->sendCommonAllStates = ARCONTROLLER_FEATURE_SkyController_SendCommonAllStates;
            featureController->sendAccessPointSettingsAccessPointSSID = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointSSID;
            featureController->sendAccessPointSettingsAccessPointChannel = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointChannel;
            featureController->sendAccessPointSettingsWifiSelection = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSelection;
            featureController->sendCameraResetOrientation = ARCONTROLLER_FEATURE_SkyController_SendCameraResetOrientation;
            featureController->sendGamepadInfosGetGamepadControls = ARCONTROLLER_FEATURE_SkyController_SendGamepadInfosGetGamepadControls;
            featureController->sendButtonMappingsGetCurrentButtonMappings = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetCurrentButtonMappings;
            featureController->sendButtonMappingsGetAvailableButtonMappings = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetAvailableButtonMappings;
            featureController->sendButtonMappingsSetButtonMapping = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsSetButtonMapping;
            featureController->sendButtonMappingsDefaultButtonMapping = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsDefaultButtonMapping;
            featureController->sendAxisMappingsGetCurrentAxisMappings = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetCurrentAxisMappings;
            featureController->sendAxisMappingsGetAvailableAxisMappings = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetAvailableAxisMappings;
            featureController->sendAxisMappingsSetAxisMapping = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsSetAxisMapping;
            featureController->sendAxisMappingsDefaultAxisMapping = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsDefaultAxisMapping;
            featureController->sendAxisFiltersGetCurrentAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetCurrentAxisFilters;
            featureController->sendAxisFiltersGetPresetAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetPresetAxisFilters;
            featureController->sendAxisFiltersSetAxisFilter = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersSetAxisFilter;
            featureController->sendAxisFiltersDefaultAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersDefaultAxisFilters;
            featureController->sendCoPilotingSetPilotingSource = ARCONTROLLER_FEATURE_SkyController_SendCoPilotingSetPilotingSource;
            featureController->sendCalibrationEnableMagnetoCalibrationQualityUpdates = ARCONTROLLER_FEATURE_SkyController_SendCalibrationEnableMagnetoCalibrationQualityUpdates;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_SkyController_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_SkyController_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_SkyController_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_SkyController_Delete (ARCONTROLLER_FEATURE_SkyController_t **feature)
{
    // -- Delete the SkyController feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_SkyController_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_SkyController_GetDictionary (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the SkyController Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_AddCallback (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>SkyController</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_RemoveCallback (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>SkyController</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_RegisterARCommands (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateWifiListCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateConnexionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateWifiSignalChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCallback (&ARCONTROLLER_FEATURE_SkyController_DeviceStateDeviceListCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_DeviceStateConnexionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateAllSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateResetChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateProductSerialChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVariantChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateProductVariantChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCallback (&ARCONTROLLER_FEATURE_SkyController_CommonStateAllStatesChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsFixChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsPositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (&ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointSSIDChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (&ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCallback (&ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateGamepadControlCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCallback (&ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateAllGamepadControlsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateCurrentButtonMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllCurrentButtonMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAvailableButtonMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllAvailableButtonsMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateCurrentAxisMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllCurrentAxisMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAvailableAxisMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllAvailableAxisMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateCurrentAxisFiltersCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllCurrentFiltersSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStatePresetAxisFiltersCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllPresetFiltersSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCallback (&ARCONTROLLER_FEATURE_SkyController_CoPilotingStatePilotingSourceCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCallback (&ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (&ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationQualityUpdatesStateCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonEventsSettingsCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonEventsSettingsCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_UnregisterARCommands (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVariantChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonEventsSettingsCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiRequestWifiList (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiRequestWifiList</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestWifiList command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiRequestWifiList(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiRequestCurrentWifi (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiRequestCurrentWifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestCurrentWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiRequestCurrentWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiConnectToWifi (ARCONTROLLER_FEATURE_SkyController_t *feature, char * bssid, char * ssid, char * passphrase)
{
    // -- Send a command <code>WifiConnectToWifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConnectToWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiConnectToWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize, bssid, ssid, passphrase);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiForgetWifi (ARCONTROLLER_FEATURE_SkyController_t *feature, char * ssid)
{
    // -- Send a command <code>WifiForgetWifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ForgetWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiForgetWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ssid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiWifiAuthChannel (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiWifiAuthChannel</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestDeviceList (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DeviceRequestDeviceList</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestDeviceList command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceRequestDeviceList(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestCurrentDevice (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DeviceRequestCurrentDevice</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestCurrentDevice command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceRequestCurrentDevice(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceConnectToDevice (ARCONTROLLER_FEATURE_SkyController_t *feature, char * deviceName)
{
    // -- Send a command <code>DeviceConnectToDevice</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConnectToDevice command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceConnectToDevice(cmdBuffer, sizeof(cmdBuffer), &cmdSize, deviceName);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendSettingsAllSettings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>SettingsAllSettings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerSettingsAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendSettingsReset (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>SettingsReset</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerSettingsReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCommonAllStates (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>CommonAllStates</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllStates command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCommonAllStates(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointSSID (ARCONTROLLER_FEATURE_SkyController_t *feature, char * ssid)
{
    // -- Send a command <code>AccessPointSettingsAccessPointSSID</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AccessPointSSID command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsAccessPointSSID(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ssid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointChannel (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t channel)
{
    // -- Send a command <code>AccessPointSettingsAccessPointChannel</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AccessPointChannel command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsAccessPointChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSelection (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>AccessPointSettingsWifiSelection</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCameraResetOrientation (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>CameraResetOrientation</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetOrientation command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCameraResetOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendGamepadInfosGetGamepadControls (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GamepadInfosGetGamepadControls</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetGamepadControls command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerGamepadInfosGetGamepadControls(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetCurrentButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ButtonMappingsGetCurrentButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentButtonMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsGetCurrentButtonMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetAvailableButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ButtonMappingsGetAvailableButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAvailableButtonMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsGetAvailableButtonMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsSetButtonMapping (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t key_id, char * mapping_uid)
{
    // -- Send a command <code>ButtonMappingsSetButtonMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetButtonMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsSetButtonMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, key_id, mapping_uid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsDefaultButtonMapping (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ButtonMappingsDefaultButtonMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultButtonMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsDefaultButtonMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetCurrentAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisMappingsGetCurrentAxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentAxisMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsGetCurrentAxisMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetAvailableAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisMappingsGetAvailableAxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAvailableAxisMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsGetAvailableAxisMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsSetAxisMapping (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t axis_id, char * mapping_uid)
{
    // -- Send a command <code>AxisMappingsSetAxisMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAxisMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsSetAxisMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, axis_id, mapping_uid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsDefaultAxisMapping (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisMappingsDefaultAxisMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultAxisMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsDefaultAxisMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetCurrentAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisFiltersGetCurrentAxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersGetCurrentAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetPresetAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisFiltersGetPresetAxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetPresetAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersGetPresetAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersSetAxisFilter (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t axis_id, char * filter_uid_or_builder)
{
    // -- Send a command <code>AxisFiltersSetAxisFilter</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAxisFilter command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersSetAxisFilter(cmdBuffer, sizeof(cmdBuffer), &cmdSize, axis_id, filter_uid_or_builder);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersDefaultAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisFiltersDefaultAxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersDefaultAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCoPilotingSetPilotingSource (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE source)
{
    // -- Send a command <code>CoPilotingSetPilotingSource</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetPilotingSource command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCoPilotingSetPilotingSource(cmdBuffer, sizeof(cmdBuffer), &cmdSize, source);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCalibrationEnableMagnetoCalibrationQualityUpdates (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t enable)
{
    // -- Send a command <code>CalibrationEnableMagnetoCalibrationQualityUpdates</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send EnableMagnetoCalibrationQualityUpdates command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCalibrationEnableMagnetoCalibrationQualityUpdates(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiListCallback (char * _bssid, char * _ssid, uint8_t _secured, uint8_t _saved, int32_t _rssi, int32_t _frequency, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiList (feature,  _bssid,  _ssid,  _secured,  _saved,  _rssi,  _frequency, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateConnexionChangedCallback (char * _ssid, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status, void *customData)
{
    // -- callback used when the command <code>WifiStateConnexionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateConnexionChanged (feature,  _ssid,  _status, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedCallback (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>WifiStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiSignalChangedCallback (uint8_t _level, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiSignalChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiSignalChanged (feature,  _level, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_DeviceStateDeviceListCallback (char * _name, void *customData)
{
    // -- callback used when the command <code>DeviceStateDeviceList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementDeviceStateDeviceList (feature,  _name, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_DeviceStateConnexionChangedCallback (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status, char * _deviceName, uint16_t _deviceProductID, void *customData)
{
    // -- callback used when the command <code>DeviceStateConnexionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementDeviceStateConnexionChanged (feature,  _status,  _deviceName,  _deviceProductID, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateAllSettingsChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateAllSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_ALLSETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateAllSettingsChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateResetChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateResetChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_RESETCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateResetChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateProductSerialChangedCallback (char * _serialNumber, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductSerialChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductSerialChanged (feature,  _serialNumber, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateProductVariantChangedCallback (eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT _variant, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductVariantChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductVariantChanged (feature,  _variant, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CommonStateAllStatesChangedCallback (void *customData)
{
    // -- callback used when the command <code>CommonStateAllStatesChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COMMONSTATE_ALLSTATESCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCommonStateAllStatesChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryChangedCallback (uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateBatteryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateBatteryChanged (feature,  _percent, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsFixChangedCallback (uint8_t _fixed, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateGpsFixChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsFixChanged (feature,  _fixed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsPositionChangedCallback (double _latitude, double _longitude, double _altitude, float _heading, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateGpsPositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsPositionChanged (feature,  _latitude,  _longitude,  _altitude,  _heading, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointSSIDChangedCallback (char * _ssid, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateAccessPointSSIDChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointSSIDChanged (feature,  _ssid, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointChannelChangedCallback (uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateAccessPointChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointChannelChanged (feature,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateGamepadControlCallback (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type, int32_t _id, char * _name, void *customData)
{
    // -- callback used when the command <code>GamepadInfosStateGamepadControl</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateGamepadControl (feature,  _type,  _id,  _name, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateAllGamepadControlsSentCallback (void *customData)
{
    // -- callback used when the command <code>GamepadInfosStateAllGamepadControlsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_ALLGAMEPADCONTROLSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateAllGamepadControlsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateCurrentButtonMappingsCallback (int32_t _key_id, char * _mapping_uid, void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateCurrentButtonMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateCurrentButtonMappings (feature,  _key_id,  _mapping_uid, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllCurrentButtonMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateAllCurrentButtonMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_ALLCURRENTBUTTONMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllCurrentButtonMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAvailableButtonMappingsCallback (char * _mapping_uid, char * _name, void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateAvailableButtonMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAvailableButtonMappings (feature,  _mapping_uid,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllAvailableButtonsMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateAllAvailableButtonsMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_ALLAVAILABLEBUTTONSMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllAvailableButtonsMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateCurrentAxisMappingsCallback (int32_t _axis_id, char * _mapping_uid, void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateCurrentAxisMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateCurrentAxisMappings (feature,  _axis_id,  _mapping_uid, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllCurrentAxisMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateAllCurrentAxisMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_ALLCURRENTAXISMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllCurrentAxisMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAvailableAxisMappingsCallback (char * _mapping_uid, char * _name, void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateAvailableAxisMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAvailableAxisMappings (feature,  _mapping_uid,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllAvailableAxisMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateAllAvailableAxisMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_ALLAVAILABLEAXISMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllAvailableAxisMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateCurrentAxisFiltersCallback (int32_t _axis_id, char * _filter_uid_or_builder, void *customData)
{
    // -- callback used when the command <code>AxisFiltersStateCurrentAxisFilters</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateCurrentAxisFilters (feature,  _axis_id,  _filter_uid_or_builder, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllCurrentFiltersSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisFiltersStateAllCurrentFiltersSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_ALLCURRENTFILTERSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllCurrentFiltersSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStatePresetAxisFiltersCallback (char * _filter_uid, char * _name, void *customData)
{
    // -- callback used when the command <code>AxisFiltersStatePresetAxisFilters</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStatePresetAxisFilters (feature,  _filter_uid,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllPresetFiltersSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisFiltersStateAllPresetFiltersSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_ALLPRESETFILTERSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllPresetFiltersSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CoPilotingStatePilotingSourceCallback (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source, void *customData)
{
    // -- callback used when the command <code>CoPilotingStatePilotingSource</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCoPilotingStatePilotingSource (feature,  _source, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateCallback (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status, uint8_t _X_Quality, uint8_t _Y_Quality, uint8_t _Z_Quality, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationState (feature,  _status,  _X_Quality,  _Y_Quality,  _Z_Quality, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationQualityUpdatesState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationQualityUpdatesState (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonEventsSettingsCallback (void *customData)
{
    // -- callback used when the command <code>ButtonEventsSettings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONEVENTS_SETTINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonEventsSettings (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiList (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _bssid, char * _ssid, uint8_t _secured, uint8_t _saved, int32_t _rssi, int32_t _frequency, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_bssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _bssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_BSSID;
            strLength = strlen (_bssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _bssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SECURED;
            argDictNewElement->value.U8 = _secured;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SAVED;
            argDictNewElement->value.U8 = _saved;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_RSSI;
            argDictNewElement->value.I32 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateConnexionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _ssid, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateConnexionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiSignalChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _level, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiSignalChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED_LEVEL;
            argDictNewElement->value.U8 = _level;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementDeviceStateDeviceList (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _name, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DeviceStateDeviceList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementDeviceStateConnexionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status, char * _deviceName, uint16_t _deviceProductID, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DeviceStateConnexionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICENAME;
            strLength = strlen (_deviceName);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _deviceName, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICEPRODUCTID;
            argDictNewElement->value.U16 = _deviceProductID;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateAllSettingsChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateAllSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateResetChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateResetChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductSerialChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _serialNumber, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductSerialChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED_SERIALNUMBER;
            strLength = strlen (_serialNumber);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serialNumber, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductVariantChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT _variant, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductVariantChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT;
            argDictNewElement->value.I32 = _variant;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCommonStateAllStatesChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateAllStatesChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateBatteryChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _percent, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateBatteryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsFixChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _fixed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateGpsFixChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED_FIXED;
            argDictNewElement->value.U8 = _fixed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsPositionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, double _latitude, double _longitude, double _altitude, float _heading, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateGpsPositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_HEADING;
            argDictNewElement->value.Float = _heading;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointSSIDChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _ssid, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateAccessPointSSIDChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointChannelChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateAccessPointChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateGamepadControl (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type, int32_t _id, char * _name, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GamepadInfosStateGamepadControl -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_ID;
            argDictNewElement->value.I32 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateAllGamepadControlsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GamepadInfosStateAllGamepadControlsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateCurrentButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t _key_id, char * _mapping_uid, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateCurrentButtonMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _key_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _key_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_KEY_ID;
            argDictNewElement->value.I32 = _key_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllCurrentButtonMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateAllCurrentButtonMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAvailableButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _mapping_uid, char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateAvailableButtonMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_mapping_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _mapping_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllAvailableButtonsMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateAllAvailableButtonsMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateCurrentAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t _axis_id, char * _mapping_uid, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateCurrentAxisMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _axis_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _axis_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_AXIS_ID;
            argDictNewElement->value.I32 = _axis_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllCurrentAxisMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateAllCurrentAxisMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAvailableAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _mapping_uid, char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateAvailableAxisMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_mapping_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _mapping_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllAvailableAxisMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateAllAvailableAxisMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateCurrentAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t _axis_id, char * _filter_uid_or_builder, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStateCurrentAxisFilters -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _axis_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _axis_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_AXIS_ID;
            argDictNewElement->value.I32 = _axis_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_FILTER_UID_OR_BUILDER;
            strLength = strlen (_filter_uid_or_builder);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filter_uid_or_builder, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllCurrentFiltersSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStateAllCurrentFiltersSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStatePresetAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature, char * _filter_uid, char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStatePresetAxisFilters -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_filter_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _filter_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_FILTER_UID;
            strLength = strlen (_filter_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filter_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllPresetFiltersSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStateAllPresetFiltersSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCoPilotingStatePilotingSource (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CoPilotingStatePilotingSource -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE;
            argDictNewElement->value.I32 = _source;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationState (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status, uint8_t _X_Quality, uint8_t _Y_Quality, uint8_t _Z_Quality, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_X_QUALITY;
            argDictNewElement->value.U8 = _X_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Y_QUALITY;
            argDictNewElement->value.U8 = _Y_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Z_QUALITY;
            argDictNewElement->value.U8 = _Z_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationQualityUpdatesState (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationQualityUpdatesState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonEventsSettings (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonEventsSettings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SetNetworkController (ARCONTROLLER_FEATURE_SkyController_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_GetCommandElements (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE wifi --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_SSID = "arcontroller_dictionary_key_wifi_scanneditem_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_RSSI = "arcontroller_dictionary_key_wifi_scanneditem_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_BAND = "arcontroller_dictionary_key_wifi_scanneditem_band";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_CHANNEL = "arcontroller_dictionary_key_wifi_scanneditem_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_BAND = "arcontroller_dictionary_key_wifi_authorizedchannel_band";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_CHANNEL = "arcontroller_dictionary_key_wifi_authorizedchannel_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_ENVIRONMENT = "arcontroller_dictionary_key_wifi_authorizedchannel_environment";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_TYPE = "arcontroller_dictionary_key_wifi_apchannelchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_BAND = "arcontroller_dictionary_key_wifi_apchannelchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_CHANNEL = "arcontroller_dictionary_key_wifi_apchannelchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY = "arcontroller_dictionary_key_wifi_securitychanged_key";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY_TYPE = "arcontroller_dictionary_key_wifi_securitychanged_key_type";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_SELECTION_MODE = "arcontroller_dictionary_key_wifi_countrychanged_selection_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_CODE = "arcontroller_dictionary_key_wifi_countrychanged_code";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_ENVIRONMENTCHANGED_ENVIRONMENT = "arcontroller_dictionary_key_wifi_environmentchanged_environment";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_RSSICHANGED_RSSI = "arcontroller_dictionary_key_wifi_rssichanged_rssi";

ARCONTROLLER_FEATURE_Wifi_t *ARCONTROLLER_FEATURE_Wifi_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Wifi_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Wifi_t));
        if (featureController != NULL)
        {
            featureController->sendScan = ARCONTROLLER_FEATURE_Wifi_SendScan;
            featureController->sendUpdateAuthorizedChannels = ARCONTROLLER_FEATURE_Wifi_SendUpdateAuthorizedChannels;
            featureController->sendSetApChannel = ARCONTROLLER_FEATURE_Wifi_SendSetApChannel;
            featureController->sendSetSecurity = ARCONTROLLER_FEATURE_Wifi_SendSetSecurity;
            featureController->sendSetCountry = ARCONTROLLER_FEATURE_Wifi_SendSetCountry;
            featureController->sendSetEnvironment = ARCONTROLLER_FEATURE_Wifi_SendSetEnvironment;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Wifi_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_Wifi_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Wifi_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Wifi_Delete (ARCONTROLLER_FEATURE_Wifi_t **feature)
{
    // -- Delete the wifi feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_Wifi_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Wifi_GetDictionary (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the wifi Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_AddCallback (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Wifi</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_RemoveCallback (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Wifi</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_RegisterARCommands (ARCONTROLLER_FEATURE_Wifi_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetWifiScannedItemCallback (&ARCONTROLLER_FEATURE_Wifi_ScannedItemCallback, feature);
        ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCallback (&ARCONTROLLER_FEATURE_Wifi_AuthorizedChannelCallback, feature);
        ARCOMMANDS_Decoder_SetWifiApChannelChangedCallback (&ARCONTROLLER_FEATURE_Wifi_ApChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiSecurityChangedCallback (&ARCONTROLLER_FEATURE_Wifi_SecurityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiCountryChangedCallback (&ARCONTROLLER_FEATURE_Wifi_CountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCallback (&ARCONTROLLER_FEATURE_Wifi_EnvironmentChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiRssiChangedCallback (&ARCONTROLLER_FEATURE_Wifi_RssiChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_UnregisterARCommands (ARCONTROLLER_FEATURE_Wifi_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetWifiScannedItemCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiApChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiSecurityChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiCountryChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiRssiChangedCallback (NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendScan (ARCONTROLLER_FEATURE_Wifi_t *feature, uint8_t band)
{
    // -- Send a command <code>Scan</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Scan command
        cmdError = ARCOMMANDS_Generator_GenerateWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendUpdateAuthorizedChannels (ARCONTROLLER_FEATURE_Wifi_t *feature)
{
    // -- Send a command <code>UpdateAuthorizedChannels</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UpdateAuthorizedChannels command
        cmdError = ARCOMMANDS_Generator_GenerateWifiUpdateAuthorizedChannels(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetApChannel (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_SELECTION_TYPE type, eARCOMMANDS_WIFI_BAND band, uint8_t channel)
{
    // -- Send a command <code>SetApChannel</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetApChannel command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetApChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetSecurity (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_SECURITY_TYPE type, char * key, eARCOMMANDS_WIFI_SECURITY_KEY_TYPE key_type)
{
    // -- Send a command <code>SetSecurity</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetSecurity command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetSecurity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, key, key_type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetCountry (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_COUNTRY_SELECTION selection_mode, char * code)
{
    // -- Send a command <code>SetCountry</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetCountry command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, selection_mode, code);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetEnvironment (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_ENVIRONMENT environment)
{
    // -- Send a command <code>SetEnvironment</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetEnvironment command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetEnvironment(cmdBuffer, sizeof(cmdBuffer), &cmdSize, environment);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Wifi_ScannedItemCallback (char * _ssid, int16_t _rssi, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>ScannedItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if (remove)
        {
            //remove
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Wifi_NewCmdElementScannedItem (feature, _ssid,  _rssi,  _band,  _channel,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
        
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_AuthorizedChannelCallback (eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _environment, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>AuthorizedChannel</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if (remove)
        {
            //remove
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            if (error == ARCONTROLLER_OK)
            {
                listIndex = HASH_COUNT (dictCmdElement->elements);
            }
            
            //Create new element
            newElement = ARCONTROLLER_Wifi_NewCmdElementAuthorizedChannel (feature, _band,  _channel,  _environment,  _list_flags, listIndex, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
        
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_ApChannelChangedCallback (eARCOMMANDS_WIFI_SELECTION_TYPE _type, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>ApChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementApChannelChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_SecurityChangedCallback (char * _key, eARCOMMANDS_WIFI_SECURITY_TYPE _key_type, void *customData)
{
    // -- callback used when the command <code>SecurityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementSecurityChanged (feature,  _key,  _key_type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_CountryChangedCallback (eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode, char * _code, void *customData)
{
    // -- callback used when the command <code>CountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementCountryChanged (feature,  _selection_mode,  _code, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_EnvironmentChangedCallback (eARCOMMANDS_WIFI_ENVIRONMENT _environment, void *customData)
{
    // -- callback used when the command <code>EnvironmentChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_ENVIRONMENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementEnvironmentChanged (feature,  _environment, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_RssiChangedCallback (int16_t _rssi, void *customData)
{
    // -- callback used when the command <code>RssiChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_RSSICHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementRssiChanged (feature,  _rssi, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementScannedItem (ARCONTROLLER_FEATURE_Wifi_t *feature, char * _ssid, int16_t _rssi, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ScannedItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementAuthorizedChannel (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _environment, uint8_t _list_flags, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AuthorizedChannel -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_ENVIRONMENT;
            argDictNewElement->value.U8 = _environment;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementApChannelChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_SELECTION_TYPE _type, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ApChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementSecurityChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, char * _key, eARCOMMANDS_WIFI_SECURITY_TYPE _key_type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SecurityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY;
            strLength = strlen (_key);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _key, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY_TYPE;
            argDictNewElement->value.I32 = _key_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementCountryChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode, char * _code, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_SELECTION_MODE;
            argDictNewElement->value.I32 = _selection_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_CODE;
            strLength = strlen (_code);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _code, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementEnvironmentChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_ENVIRONMENT _environment, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event EnvironmentChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_ENVIRONMENTCHANGED_ENVIRONMENT;
            argDictNewElement->value.I32 = _environment;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementRssiChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, int16_t _rssi, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RssiChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_RSSICHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SetNetworkController (ARCONTROLLER_FEATURE_Wifi_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_GetCommandElements (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
